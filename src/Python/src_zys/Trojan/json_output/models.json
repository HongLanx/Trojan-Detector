"Module(body=[ImportFrom(module='trojanzoo.configs', names=[alias(name='config')], level=0), ImportFrom(module='trojanzoo.datasets', names=[alias(name='Dataset')], level=0), ImportFrom(module='trojanzoo.environ', names=[alias(name='env')], level=0), ImportFrom(module='trojanzoo.utils.fim', names=[alias(name='KFAC'), alias(name='EKFAC')], level=0), ImportFrom(module='trojanzoo.utils.model', names=[alias(name='get_all_layer'), alias(name='get_layer'), alias(name='get_layer_name'), alias(name='activate_params'), alias(name='accuracy'), alias(name='generate_target'), alias(name='summary')], level=0), ImportFrom(module='trojanzoo.utils.module', names=[alias(name='get_name'), alias(name='BasicObject')], level=0), ImportFrom(module='trojanzoo.utils.output', names=[alias(name='ansi'), alias(name='prints')], level=0), ImportFrom(module='trojanzoo.utils.tensor', names=[alias(name='add_noise')], level=0), ImportFrom(module='trojanzoo.utils.train', names=[alias(name='train'), alias(name='validate'), alias(name='compare')], level=0), Import(names=[alias(name='torch')]), Import(names=[alias(name='torch.nn', asname='nn')]), Import(names=[alias(name='numpy', asname='np')]), Import(names=[alias(name='os')]), ImportFrom(module='collections', names=[alias(name='OrderedDict')], level=0), ImportFrom(module='collections.abc', names=[alias(name='Iterable')], level=0), ImportFrom(module='typing', names=[alias(name='TYPE_CHECKING')], level=0), ImportFrom(module='typing', names=[alias(name='Generator'), alias(name='Iterator'), alias(name='Mapping'), alias(name='Self')], level=0), ImportFrom(module='trojanzoo.configs', names=[alias(name='Config')], level=0), ImportFrom(module='trojanzoo.utils.model', names=[alias(name='ExponentialMovingAverage')], level=0), ImportFrom(module='torch.optim.optimizer', names=[alias(name='Optimizer')], level=0), ImportFrom(module='torch.optim.lr_scheduler', names=[alias(name='_LRScheduler')], level=0), ImportFrom(module='torchvision.models._api', names=[alias(name='WeightsEnum')], level=0), Import(names=[alias(name='argparse')]), ImportFrom(module='collections.abc', names=[alias(name='Callable')], level=0), If(test=Name(id='TYPE_CHECKING', ctx=Load()), body=[Import(names=[alias(name='torch.utils.data')])], orelse=[]), Assign(targets=[Name(id='__all__', ctx=Store())], value=List(elts=[Constant(value='_Model'), Constant(value='Model'), Constant(value='add_argument'), Constant(value='create'), Constant(value='output_available_models')], ctx=Load())), ClassDef(name='_Model', bases=[Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())], keywords=[], body=[Expr(value=Constant(value='A specific model class which inherits :any:`torch.nn.Module`.\\n\\n    Args:\\n        num_classes (int): Number of classes.\\n        **kwargs: Keyword arguments passed to :meth:`define_preprocess`,\\n            :meth:`define_features` and :meth:`define_classifier`.\\n\\n    Attributes:\\n        num_classes (int): Number of classes. Defaults to ``None``.\\n\\n        preprocess (torch.nn.Module): Defaults to :meth:`define_preprocess()`.\\n        features (torch.nn.Module): Defaults to :meth:`define_features()`.\\n        pool (torch.nn.Module): :any:`torch.nn.AdaptiveAvgPool2d` ``((1, 1))``.\\n        classifier (torch.nn.Module): Defaults to :meth:`define_classifier()`.\\n    ')), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='num_classes', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='preprocess', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='define_preprocess', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='features', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='define_features', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Store())], value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='AdaptiveAvgPool2d', ctx=Load()), args=[Tuple(elts=[Constant(value=1), Constant(value=1)], ctx=Load())], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='flatten', ctx=Store())], value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Flatten', ctx=Load()), args=[], keywords=[])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='classifier', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='define_classifier', ctx=Load()), args=[], keywords=[keyword(arg='num_classes', value=Name(id='num_classes', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='num_classes', ctx=Store())], value=Name(id='num_classes', ctx=Load()))], decorator_list=[]), FunctionDef(name='define_preprocess', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Define preprocess before feature extractor.\\n\\n        Returns:\\n            torch.nn.Identity: Identity module.\\n        ')), Return(value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Identity', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='classmethod', ctx=Load())], returns=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())), FunctionDef(name='define_features', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Define feature extractor.\\n\\n        Returns:\\n            torch.nn.Identity: Identity module.\\n        ')), Return(value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Identity', ctx=Load()), args=[], keywords=[]))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())), FunctionDef(name='define_classifier', args=arguments(posonlyargs=[], args=[arg(arg='num_features', annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load())), arg(arg='activation', annotation=Subscript(value=Name(id='type', ctx=Load()), slice=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load()), ctx=Load())), arg(arg='activation_inplace', annotation=Name(id='bool', ctx=Load())), arg(arg='dropout', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[List(elts=[], ctx=Load()), Constant(value=1000), Attribute(value=Name(id='nn', ctx=Load()), attr='ReLU', ctx=Load()), Constant(value=True), Constant(value=0.0)]), body=[Expr(value=Constant(value=\"\\n        | Define classifier as\\n            ``(Linear -> Activation -> Dropout ) * (len(num_features) - 1) -> Linear``.\\n        | If there is only 1 linear layer, its name will be ``'fc'``.\\n        | Else, all layer names will be indexed starting from ``0``\\n            (e.g., ``'fc1', 'relu1', 'dropout0'``).\\n\\n        Args:\\n            num_features (list[int]): List of feature numbers.\\n                Each element serves as the :attr:`in_features` of current layer\\n                and :attr:`out_features` of preceding layer.\\n                Defaults to ``[]``.\\n            num_classes (int): The number of classes.\\n                This serves as the :attr:`out_features` of last layer.\\n                Defaults to ``None``.\\n            activation (type[torch.nn.Module]):\\n                The type of activation layer.\\n                Defaults to :any:`torch.nn.ReLU`.\\n            activation_inplace (bool): Whether to use inplace activation.\\n                Defaults to ``'True'``\\n            dropout (float): The drop out probability.\\n                Will **NOT** add dropout layers if it's ``0``.\\n                Defaults to ``0.0``.\\n            **kwargs: Any keyword argument (unused).\\n\\n        Returns:\\n            torch.nn.Sequential: The sequential classifier.\\n\\n        :Examples:\\n            >>> from trojanzoo.models import _Model\\n            >>>\\n            >>> _Model.define_classifier(num_features=[5,4,4], num_classes=10)\\n            Sequential(\\n                (fc1): Linear(in_features=5, out_features=4, bias=True)\\n                (relu1): ReLU(inplace=True)\\n                (dropout1): Dropout(p=0.5, inplace=False)\\n                (fc2): Linear(in_features=4, out_features=4, bias=True)\\n                (relu2): ReLU(inplace=True)\\n                (dropout2): Dropout(p=0.5, inplace=False)\\n                (fc3): Linear(in_features=4, out_features=10, bias=True)\\n            )\\n        \")), Assign(targets=[Name(id='seq', ctx=Store())], value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Sequential', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='num_features', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=0)]), body=[Return(value=Name(id='seq', ctx=Load()))], orelse=[]), If(test=Name(id='activation', ctx=Load()), body=[Assign(targets=[Name(id='activation_name', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Attribute(value=Name(id='activation', ctx=Load()), attr='__name__', ctx=Load()), attr='split', ctx=Load()), args=[Constant(value='.')], keywords=[]), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[]))], orelse=[]), If(test=Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='num_features', ctx=Load())], keywords=[]), ops=[Eq()], comparators=[Constant(value=1)]), body=[Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='add_module', ctx=Load()), args=[Constant(value='fc'), Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Linear', ctx=Load()), args=[Subscript(value=Name(id='num_features', ctx=Load()), slice=Constant(value=0), ctx=Load()), Name(id='num_classes', ctx=Load())], keywords=[])], keywords=[]))], orelse=[For(target=Name(id='i', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[BinOp(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='num_features', ctx=Load())], keywords=[]), op=Sub(), right=Constant(value=1))], keywords=[]), body=[Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='add_module', ctx=Load()), args=[JoinedStr(values=[Constant(value='fc'), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1, format_spec=JoinedStr(values=[Constant(value='d')]))]), Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Linear', ctx=Load()), args=[Subscript(value=Name(id='num_features', ctx=Load()), slice=Name(id='i', ctx=Load()), ctx=Load()), Subscript(value=Name(id='num_features', ctx=Load()), slice=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), ctx=Load())], keywords=[])], keywords=[])), If(test=Name(id='activation', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='add_module', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='activation_name', ctx=Load()), conversion=-1), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1, format_spec=JoinedStr(values=[Constant(value='d')]))]), Call(func=Name(id='activation', ctx=Load()), args=[], keywords=[keyword(arg='inplace', value=Name(id='activation_inplace', ctx=Load()))])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='dropout', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='add_module', ctx=Load()), args=[JoinedStr(values=[Constant(value='dropout'), FormattedValue(value=BinOp(left=Name(id='i', ctx=Load()), op=Add(), right=Constant(value=1)), conversion=-1, format_spec=JoinedStr(values=[Constant(value='d')]))]), Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Dropout', ctx=Load()), args=[], keywords=[keyword(arg='p', value=Name(id='dropout', ctx=Load()))])], keywords=[]))], orelse=[])], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='seq', ctx=Load()), attr='add_module', ctx=Load()), args=[JoinedStr(values=[Constant(value='fc'), FormattedValue(value=Call(func=Name(id='len', ctx=Load()), args=[Name(id='num_features', ctx=Load())], keywords=[]), conversion=-1, format_spec=JoinedStr(values=[Constant(value='d')]))]), Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Linear', ctx=Load()), args=[Subscript(value=Name(id='num_features', ctx=Load()), slice=UnaryOp(op=USub(), operand=Constant(value=1)), ctx=Load()), Name(id='num_classes', ctx=Load())], keywords=[])], keywords=[]))]), Return(value=Name(id='seq', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='nn', ctx=Load()), attr='Sequential', ctx=Load())), FunctionDef(name='forward', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='``x -> self.get_final_fm -> self.classifier -> return``')), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_final_fm', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='classifier', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Return(value=Name(id='x', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_fm', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='``x -> self.preprocess -> self.features -> return``')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='features', ctx=Load()), args=[Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='preprocess', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_final_fm', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='x', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='``x -> self.get_fm -> self.pool -> self.flatten -> return``')), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_fm', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='pool', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Assign(targets=[Name(id='x', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='flatten', ctx=Load()), args=[Name(id='x', ctx=Load())], keywords=[])), Return(value=Name(id='x', ctx=Load()))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self')], vararg=arg(arg='args'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Return(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__call__', ctx=Load()), args=[Starred(value=Name(id='args', ctx=Load()), ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], decorator_list=[]), ClassDef(name='Model', bases=[Name(id='BasicObject', ctx=Load())], keywords=[], body=[Expr(value=Constant(value=\"\\n    | A general model wrapper class, which should be the most common interface for users.\\n    | It inherits :class:`trojanzoo.utils.module.BasicObject`.\\n\\n    Args:\\n        name (str): Name of model.\\n        suffix (str):\\n            | Suffix of local model weights file (e.g., ``'_adv_train'``).\\n              Defaults to empty string ``''``.\\n            | The location of local pretrained weights is\\n              ``'{folder_path}/{self.name}{self.suffix}.pth'``\\n        model (type[_Model] | _Model): Type of model or a specific model instance.\\n        dataset (trojanzoo.datasets.Dataset | None): Corresponding dataset (optional).\\n            Defaults to ``None``.\\n        num_classes (int | None): Number of classes.\\n            If it's ``None``, fetch the value from :attr:`dataset`.\\n            Defaults to ``None``.\\n        folder_path (str): Folder path to save model weights.\\n            Defaults to ``None``.\\n\\n            Note:\\n                :attr:`folder_path` is usually\\n                ``'{model_dir}/{dataset.data_type}/{dataset.name}'``,\\n                which is claimed as the default value of :func:`create()`.\\n        official (bool): Whether to use official pretrained weights.\\n            Defaults to ``False``.\\n        pretrained (bool): Whether to use local pretrained weights\\n            from ``'{folder_path}/{self.name}{self.suffix}.pth'``\\n            Defaults to ``False``.\\n        randomized_smooth (bool): Whether to use randomized smoothing.\\n            Defaults to ``False``.\\n        rs_sigma (float): Randomized smoothing sampling std :math:`\\\\sigma`.\\n            Defaults to ``0.01``.\\n        rs_n (int): Randomized smoothing sampling number. Defaults to ``100``.\\n\\n    Attributes:\\n        available_models (set[str]): The list of available model names.\\n        weights (~torchvision.models._api.WeightsEnum): The pretrained weights to use.\\n\\n        name (str): Name of model.\\n        suffix (str):\\n            | Suffix of local model weights file (e.g., ``'_adv_train'``).\\n              Defaults to empty string ``''``.\\n            | The location of local pretrained weights is\\n              ``'{folder_path}/{self.name}{self.suffix}.pth'``\\n        _model (_Model): :any:`torch.nn.Module` model instance.\\n        model (torch.nn.DataParallel | _Model):\\n            Parallel version of :attr:`_model` if there is more than 1 GPU available.\\n            Generated by :meth:`get_parallel_model()`.\\n        dataset (trojanzoo.datasets.Dataset | None): Corresponding dataset (optional).\\n            Defaults to ``None``.\\n        num_classes (int | None): Number of classes.\\n            If it's ``None``, fetch the value from :attr:`dataset`.\\n            Defaults to ``None``.\\n        folder_path (str): Folder path to save model weights.\\n            Defaults to ``None``.\\n        randomized_smooth (bool): Whether to use randomized smoothing.\\n            Defaults to ``False``.\\n        rs_sigma (float): Randomized smoothing sampling std :math:`\\\\sigma`.\\n        rs_n (int): Randomized smoothing sampling number. Defaults to ``100``.\\n\\n        criterion (~collections.abc.Callable):\\n            The criterion used to calculate :meth:`loss()`.\\n        criterion_noreduction (~collections.abc.Callable):\\n            The criterion used to calculate :meth:`loss()`\\n            when ``reduction='none'``.\\n        softmax (torch.nn.Module): :any:`torch.nn.Softmax` ``(dim=1)``.\\n            Used in :meth:`get_prob()`.\\n    \")), AnnAssign(target=Name(id='available_models', ctx=Store()), annotation=Subscript(value=Name(id='set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Name(id='set', ctx=Load()), args=[], keywords=[]), simple=1), AnnAssign(target=Name(id='weights', ctx=Store()), annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='WeightsEnum', ctx=Load())], ctx=Load()), ctx=Load()), value=Constant(value=None), simple=1), FunctionDef(name='add_argument', args=arguments(posonlyargs=[], args=[arg(arg='group', annotation=Attribute(value=Name(id='argparse', ctx=Load()), attr='_ArgumentGroup', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Add model arguments to argument parser group.\\n        View source to see specific arguments.\\n\\n        Note:\\n            This is the implementation of adding arguments.\\n            The concrete model class may override this method to add more arguments.\\n            For users, please use :func:`add_argument()` instead, which is more user-friendly.\\n        ')), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='-m'), Constant(value='--model')], keywords=[keyword(arg='dest', value=Constant(value='model_name')), keyword(arg='help', value=Constant(value='model name (default: config[model][default_model])'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--suffix')], keywords=[keyword(arg='help', value=Constant(value='model name suffix (e.g., \"_adv_train\")'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--pretrained')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='load local pretrained weights (default: False)'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--official')], keywords=[keyword(arg='action', value=Constant(value='store_true')), keyword(arg='help', value=Constant(value='load official pretrained weights (default: False)'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--randomized_smooth')], keywords=[keyword(arg='help', value=Constant(value='whether to use randomized smoothing (default: False)'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--rs_sigma')], keywords=[keyword(arg='type', value=Name(id='float', ctx=Load())), keyword(arg='help', value=Constant(value='randomized smoothing sampling std (default: 0.01)'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--rs_n')], keywords=[keyword(arg='type', value=Name(id='int', ctx=Load())), keyword(arg='help', value=Constant(value='randomized smoothing sampling number (default: 100)'))])), Expr(value=Call(func=Attribute(value=Name(id='group', ctx=Load()), attr='add_argument', ctx=Load()), args=[Constant(value='--model_dir')], keywords=[keyword(arg='help', value=Constant(value='directory to store pretrained models'))])), Return(value=Name(id='group', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=Attribute(value=Name(id='argparse', ctx=Load()), attr='_ArgumentGroup', ctx=Load())), FunctionDef(name='__init__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='suffix', annotation=Name(id='str', ctx=Load())), arg(arg='model', annotation=BinOp(left=Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='_Model', ctx=Load()), ctx=Load()), op=BitOr(), right=Name(id='_Model', ctx=Load()))), arg(arg='dataset', annotation=Name(id='Dataset', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load())), arg(arg='folder_path', annotation=Name(id='str', ctx=Load())), arg(arg='official', annotation=Name(id='bool', ctx=Load())), arg(arg='pretrained', annotation=Name(id='bool', ctx=Load())), arg(arg='randomized_smooth', annotation=Name(id='bool', ctx=Load())), arg(arg='rs_sigma', annotation=Name(id='float', ctx=Load())), arg(arg='rs_n', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value='model'), Constant(value=None), Name(id='_Model', ctx=Load()), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=False), Constant(value=False), Constant(value=False), Constant(value=0.01), Constant(value=100)]), body=[Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='__init__', ctx=Load()), args=[], keywords=[])), Assign(targets=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='param_list', ctx=Load()), slice=Constant(value='model'), ctx=Store())], value=List(elts=[Constant(value='folder_path')], ctx=Load())), If(test=Compare(left=Name(id='suffix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='param_list', ctx=Load()), slice=Constant(value='model'), ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='suffix')], keywords=[]))], orelse=[Assign(targets=[Name(id='suffix', ctx=Store())], value=Constant(value=''))]), If(test=Name(id='randomized_smooth', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='param_list', ctx=Load()), slice=Constant(value='model'), ctx=Load()), attr='extend', ctx=Load()), args=[List(elts=[Constant(value='randomized_smooth'), Constant(value='rs_sigma'), Constant(value='rs_n')], ctx=Load())], keywords=[]))], orelse=[]), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Name(id='name', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Store())], value=Name(id='dataset', ctx=Load())), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='suffix', ctx=Store())], value=Name(id='suffix', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='randomized_smooth', ctx=Store()), annotation=Name(id='bool', ctx=Load()), value=Name(id='randomized_smooth', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='rs_sigma', ctx=Store()), annotation=Name(id='float', ctx=Load()), value=Name(id='rs_sigma', ctx=Load()), simple=0), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='rs_n', ctx=Store()), annotation=Name(id='int', ctx=Load()), value=Name(id='rs_n', ctx=Load()), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='folder_path', ctx=Store())], value=Name(id='folder_path', ctx=Load())), If(test=Compare(left=Name(id='folder_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='folder_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]))], orelse=[])], orelse=[]), AnnAssign(target=Name(id='loss_weights', ctx=Store()), annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='loss_weights'), Constant(value=None)], keywords=[]), simple=1), If(test=Name(id='dataset', ctx=Load()), body=[If(test=UnaryOp(op=Not(), operand=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dataset', ctx=Load()), Name(id='Dataset', ctx=Load())], keywords=[])), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='type(dataset)='), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='dataset', ctx=Load())], keywords=[]), conversion=114), Constant(value='    dataset='), FormattedValue(value=Name(id='dataset', ctx=Load()), conversion=114)])], keywords=[]))], orelse=[]), Assign(targets=[Name(id='num_classes', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='num_classes', ctx=Load()), Attribute(value=Name(id='dataset', ctx=Load()), attr='num_classes', ctx=Load())])), Assign(targets=[Name(id='loss_weights', ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='loss_weights'), Attribute(value=Name(id='dataset', ctx=Load()), attr='loss_weights', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='num_classes', ctx=Store())], value=Name(id='num_classes', ctx=Load())), Match(subject=Name(id='loss_weights', ctx=Load()), cases=[match_case(pattern=MatchClass(cls=Attribute(value=Name(id='np', ctx=Load()), attr='ndarray', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Name(id='loss_weights', ctx=Store())], value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='from_numpy', ctx=Load()), args=[Name(id='loss_weights', ctx=Load())], keywords=[]), attr='to', ctx=Load()), args=[], keywords=[keyword(arg='device', value=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='device'), ctx=Load())), keyword(arg='dtype', value=Attribute(value=Name(id='torch', ctx=Load()), attr='float', ctx=Load()))]))]), match_case(pattern=MatchClass(cls=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Name(id='loss_weights', ctx=Store())], value=Call(func=Attribute(value=Name(id='loss_weights', ctx=Load()), attr='to', ctx=Load()), args=[], keywords=[keyword(arg='device', value=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='device'), ctx=Load())), keyword(arg='dtype', value=Attribute(value=Name(id='torch', ctx=Load()), attr='float', ctx=Load()))]))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='loss_weights', ctx=Store())], value=Name(id='loss_weights', ctx=Load())), AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Constant(value=None), simple=0), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='criterion', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='define_criterion', ctx=Load()), args=[], keywords=[keyword(arg='weight', value=Name(id='loss_weights', ctx=Load()))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='criterion_noreduction', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='define_criterion', ctx=Load()), args=[], keywords=[keyword(arg='weight', value=Name(id='loss_weights', ctx=Load())), keyword(arg='reduction', value=Constant(value='none'))])), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='softmax', ctx=Store())], value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='Softmax', ctx=Load()), args=[], keywords=[keyword(arg='dim', value=Constant(value=1))])), Match(subject=Name(id='model', ctx=Load()), cases=[match_case(pattern=MatchClass(cls=Name(id='type', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[If(test=Compare(left=Name(id='num_classes', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='num_classes'), ctx=Store())], value=Name(id='num_classes', ctx=Load()))], orelse=[]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Call(func=Name(id='model', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='name', ctx=Load())), keyword(arg='dataset', value=Name(id='dataset', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))]), match_case(pattern=MatchClass(cls=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Store())], value=Name(id='model', ctx=Load()))]), match_case(pattern=MatchAs(), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[Call(func=Name(id='type', ctx=Load()), args=[Name(id='model', ctx=Load())], keywords=[])], keywords=[]))])]), Assign(targets=[Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_parallel_model', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='activate_params', ctx=Load()), args=[List(elts=[], ctx=Load())], keywords=[])), If(test=Name(id='official', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='load', ctx=Load()), args=[Constant(value='official')], keywords=[]))], orelse=[]), If(test=Name(id='pretrained', ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='load', ctx=Load()), args=[], keywords=[keyword(arg='verbose', value=Constant(value=True))]))], orelse=[]), Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), If(test=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='num_gpus'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='cuda', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[]), FunctionDef(name='get_logits', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='parallel', annotation=Name(id='bool', ctx=Load())), arg(arg='randomized_smooth', annotation=Name(id='bool', ctx=Load())), arg(arg='rs_sigma', annotation=Name(id='float', ctx=Load())), arg(arg='rs_n', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value=\"Get logits of :attr:`_input`.\\n\\n        Note:\\n            Users should use model as Callable function\\n            rather than call this method directly,\\n            because ``__call__`` supports :any:`torch.cuda.amp`.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor.\\n            parallel (bool): Whether to use parallel model\\n                `self.model` rather than `self._model`.\\n                Defautls to ``False``.\\n            randomized_smooth (bool | None): Whether to use randomized smoothing.\\n                If it's ``None``, use :attr:`self.randmized_smooth` instead.\\n                Defaults to ``None``.\\n            rs_sigma (float | None): Randomized smoothing sampling std :math:`\\\\sigma`.\\n                If it's ``None``, use :attr:`self.rs_sigma` instead.\\n                Defaults to ``None``.\\n            rs_n (int): Randomized smoothing sampling number.\\n                If it's ``None``, use :attr:`self.rs_n` instead.\\n                Defaults to ``None``.\\n            **kwargs: Keyword arguments passed to :meth:`forward()`.\\n\\n        Returns:\\n            torch.Tensor: The logit tensor with shape ``(N, C)``.\\n        \")), Assign(targets=[Name(id='model', ctx=Store())], value=IfExp(test=Name(id='parallel', ctx=Load()), body=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()))), If(test=Compare(left=Name(id='randomized_smooth', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='randomized_smooth', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='randomized_smooth', ctx=Load()))], orelse=[]), If(test=Name(id='randomized_smooth', ctx=Load()), body=[Assign(targets=[Name(id='rs_sigma', ctx=Store())], value=IfExp(test=Compare(left=Name(id='rs_sigma', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='rs_sigma', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='rs_sigma', ctx=Load()))), Assign(targets=[Name(id='rs_n', ctx=Store())], value=IfExp(test=Compare(left=Name(id='rs_n', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='rs_n', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='rs_n', ctx=Load()))), Assign(targets=[Name(id='_list', ctx=Store())], value=List(elts=[], ctx=Load())), For(target=Name(id='_', ctx=Store()), iter=Call(func=Name(id='range', ctx=Load()), args=[Name(id='rs_n', ctx=Load())], keywords=[]), body=[Assign(targets=[Name(id='_input_noise', ctx=Store())], value=Call(func=Name(id='add_noise', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(arg='std', value=Name(id='rs_sigma', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Name(id='_list', ctx=Load()), attr='append', ctx=Load()), args=[Call(func=Name(id='model', ctx=Load()), args=[Name(id='_input_noise', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='stack', ctx=Load()), args=[Name(id='_list', ctx=Load())], keywords=[]), attr='mean', ctx=Load()), args=[], keywords=[keyword(arg='dim', value=Constant(value=0))]))], orelse=[Return(value=Call(func=Name(id='model', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))])], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_fm', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value=\"Get the feature map of :attr:`_input`,\\n        which is the output of :attr:`self.features`\\n        and input of :attr:`self.pool`.\\n        Call :meth:`_Model.get_fm()`.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                passed to :meth:`_Model.get_fm()`.\\n            **kwargs: Keyword arguments passed to :meth:`_Model.get_fm()`.\\n\\n        Returns:\\n            torch.Tensor: The feature tensor with shape ``(N, C', H', W')``.\\n        \")), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='get_fm', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_final_fm', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Get the final feature map of :attr:`_input`,\\n        which is the output of :attr:`self.flatten`\\n        and input of :attr:`self.classifier`.\\n        Call :meth:`_Model.get_final_fm()`.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                passed to :meth:`_Model.get_final_fm()`.\\n            **kwargs: Keyword arguments passed to :meth:`_Model.get_final_fm()`.\\n\\n        Returns:\\n            torch.Tensor: The feature tensor with shape ``(N, dim)``.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='get_final_fm', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_prob', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Get the probability classification vector of :attr:`_input`.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                passed to :meth:`_Model.get_logits()`.\\n            **kwargs: Keyword arguments passed to :meth:`get_logits()`.\\n\\n        Returns:\\n            torch.Tensor: The probability tensor with shape ``(N, C)``.\\n        ')), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='softmax', ctx=Load()), args=[Call(func=Name(id='self', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_target_prob', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='target', annotation=BinOp(left=BinOp(left=Name(id='int', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Get the probability w.r.t. :attr:`target` class of :attr:`_input`\\n        (using :any:`torch.gather`).\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                passed to :meth:`_Model.get_logits()`.\\n            target (int | list[int] | torch.Tensor): Batched target classes.\\n            **kwargs: Keyword arguments passed to :meth:`get_logits()`.\\n\\n        Returns:\\n            torch.Tensor: The probability tensor with shape ``(N)``.\\n        ')), Match(subject=Name(id='target', ctx=Load()), cases=[match_case(pattern=MatchClass(cls=Name(id='int', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Name(id='target', ctx=Store())], value=BinOp(left=List(elts=[Name(id='target', ctx=Load())], ctx=Load()), op=Mult(), right=Call(func=Name(id='len', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[])))]), match_case(pattern=MatchClass(cls=Name(id='list', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Name(id='target', ctx=Store())], value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='tensor', ctx=Load()), args=[Name(id='target', ctx=Load())], keywords=[keyword(arg='device', value=Attribute(value=Name(id='_input', ctx=Load()), attr='device', ctx=Load()))]))])]), Return(value=Call(func=Attribute(value=Call(func=Attribute(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_prob', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]), attr='gather', ctx=Load()), args=[], keywords=[keyword(arg='dim', value=Constant(value=1)), keyword(arg='index', value=Call(func=Attribute(value=Name(id='target', ctx=Load()), attr='unsqueeze', ctx=Load()), args=[Constant(value=1)], keywords=[]))]), attr='flatten', ctx=Load()), args=[], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_class', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Get the class classification result of :attr:`_input`\\n        (using :any:`torch.argmax`).\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                passed to :meth:`_Model.get_logits()`.\\n            **kwargs: Keyword arguments passed to :meth:`get_logits()`.\\n\\n        Returns:\\n            torch.Tensor: The classes tensor with shape ``(N)``.\\n        ')), Return(value=Call(func=Attribute(value=Call(func=Name(id='self', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]), attr='argmax', ctx=Load()), args=[], keywords=[keyword(arg='dim', value=UnaryOp(op=USub(), operand=Constant(value=1)))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_layer_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='depth', annotation=Name(id='int', ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='use_filter', annotation=Name(id='bool', ctx=Load())), arg(arg='non_leaf', annotation=Name(id='bool', ctx=Load())), arg(arg='seq_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=''), Constant(value=True), Constant(value=False), Constant(value=False)]), body=[Expr(value=Constant(value=\"Get layer names of model instance.\\n\\n        Args:\\n            depth (int): The traverse depth.\\n                Defaults to ``-1`` (means :math:`\\\\infty`).\\n            prefix (str): The prefix string to all elements.\\n                Defaults to empty string ``''``.\\n            use_filter (bool): Whether to filter out certain layer types.\\n\\n                * :any:`torchvision.transforms.Normalize`\\n                * :any:`torch.nn.Dropout`\\n                * :any:`torch.nn.BatchNorm2d`\\n                * :any:`torch.nn.ReLU`\\n                * :any:`torch.nn.Sigmoid`\\n            non_leaf (bool): Whether to include non-leaf nodes.\\n                Defaults to ``False``.\\n            seq_only (bool): Whether to only traverse children\\n                of :any:`torch.nn.Sequential`.\\n                If ``False``, will traverse children of all :any:`torch.nn.Module`.\\n                Defaults to ``False``.\\n\\n        Returns:\\n            list[str]: The list of all layer names.\\n\\n        See Also:\\n            The implementation is in\\n            :func:`trojanzoo.utils.model.get_layer_name()`.\\n        \")), Return(value=Call(func=Name(id='get_layer_name', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), Name(id='depth', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='use_filter', ctx=Load()), Name(id='non_leaf', ctx=Load()), Name(id='seq_only', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())), FunctionDef(name='get_all_layer', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='layer_input', annotation=Name(id='str', ctx=Load())), arg(arg='depth', annotation=Name(id='int', ctx=Load())), arg(arg='prefix'), arg(arg='use_filter', annotation=Name(id='bool', ctx=Load())), arg(arg='non_leaf', annotation=Name(id='bool', ctx=Load())), arg(arg='seq_only', annotation=Name(id='bool', ctx=Load())), arg(arg='verbose', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='input'), UnaryOp(op=USub(), operand=Constant(value=1)), Constant(value=''), Constant(value=True), Constant(value=False), Constant(value=True), Constant(value=0)]), body=[Expr(value=Constant(value=\"Get all intermediate layer outputs of\\n        :attr:`_input` from any intermediate layer.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                from :attr:`layer_input`.\\n            layer_input (str): The intermediate layer name of :attr:`_input`.\\n                Defaults to ``'input'``.\\n            depth (int): The traverse depth.\\n                Defaults to ``-1`` (:math:`\\\\infty`).\\n            prefix (str): The prefix string to all elements.\\n                Defaults to empty string ``''``.\\n            use_filter (bool): Whether to filter out certain layer types.\\n\\n                * :any:`torchvision.transforms.Normalize`\\n                * :any:`torch.nn.Dropout`\\n                * :any:`torch.nn.BatchNorm2d`\\n                * :any:`torch.nn.ReLU`\\n                * :any:`torch.nn.Sigmoid`\\n            non_leaf (bool): Whether to include non-leaf nodes.\\n                Defaults to ``False``.\\n            seq_only (bool): Whether to only traverse children\\n                of :any:`torch.nn.Sequential`.\\n                If ``False``, will traverse children of all :any:`torch.nn.Module`.\\n                Defaults to ``False``.\\n            verbose (bool): The output level to show information\\n                including layer name, output shape and module information.\\n                Setting it larger than ``0`` will enable the output.\\n                Different integer values stands for different module information.\\n                Defaults to ``0``.\\n\\n                * ``0``: No output\\n                * ``1``: Show layer class name.\\n                * ``2``: Show layer string (first line).\\n                * ``3``: Show layer string (full).\\n\\n        Returns:\\n            dict[str, torch.Tensor]: The dict of all layer outputs.\\n\\n        See Also:\\n            The implementation is in\\n            :func:`trojanzoo.utils.model.get_all_layer()`.\\n        \")), Return(value=Call(func=Name(id='get_all_layer', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), Name(id='_input', ctx=Load()), Name(id='layer_input', ctx=Load()), Name(id='depth', ctx=Load()), Name(id='prefix', ctx=Load()), Name(id='use_filter', ctx=Load()), Name(id='non_leaf', ctx=Load()), Name(id='seq_only', ctx=Load()), Name(id='verbose', ctx=Load())], keywords=[]))], decorator_list=[], returns=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_layer', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='layer_output', annotation=Name(id='str', ctx=Load())), arg(arg='layer_input', annotation=Name(id='str', ctx=Load())), arg(arg='seq_only', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='classifier'), Constant(value='input'), Constant(value=True)]), body=[Expr(value=Constant(value=\"Get one certain intermediate layer output\\n        of :attr:`_input` from any intermediate layer.\\n\\n        Args:\\n            _input (torch.Tensor): The batched input tensor\\n                from :attr:`layer_input`.\\n            layer_output (str): The intermediate output layer name.\\n                Defaults to ``'classifier'``.\\n            layer_input (str): The intermediate layer name of :attr:`_input`.\\n                Defaults to ``'input'``.\\n            seq_only (bool): Whether to only traverse children\\n                of :any:`torch.nn.Sequential`.\\n                If ``False``, will traverse children of all :any:`torch.nn.Module`.\\n                Defaults to ``True``.\\n\\n        Returns:\\n            torch.Tensor: The output of layer :attr:`layer_output`.\\n\\n        See Also:\\n            The implementation is in\\n            :func:`trojanzoo.utils.model.get_layer()`.\\n        \")), If(test=Compare(left=Name(id='layer_input', ctx=Load()), ops=[Eq()], comparators=[Constant(value='input')]), body=[Match(subject=Name(id='layer_output', ctx=Load()), cases=[match_case(pattern=MatchValue(value=Constant(value='classifier')), body=[Return(value=Call(func=Name(id='self', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[]))]), match_case(pattern=MatchValue(value=Constant(value='features')), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='get_fm', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[]))]), match_case(pattern=MatchValue(value=Constant(value='flatten')), body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_final_fm', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[]))])])], orelse=[]), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[AnnAssign(target=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Store()), annotation=Subscript(value=Name(id='list', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_layer_name', ctx=Load()), args=[], keywords=[keyword(arg='use_filter', value=Constant(value=False)), keyword(arg='non_leaf', value=Constant(value=True))]), simple=0), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Load()), attr='insert', ctx=Load()), args=[Constant(value=0), Constant(value='input')], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Load()), attr='append', ctx=Load()), args=[Constant(value='output')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='get_layer', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), Name(id='_input', ctx=Load()), Name(id='layer_output', ctx=Load()), Name(id='layer_input', ctx=Load())], keywords=[keyword(arg='layer_name_list', value=Attribute(value=Name(id='self', ctx=Load()), attr='layer_name_list', ctx=Load())), keyword(arg='seq_only', value=Name(id='seq_only', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='loss', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='_label', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='_output', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='reduction', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='mean')]), body=[Expr(value=Constant(value=\"Calculate the loss using :attr:`self.criterion`\\n        (:attr:`self.criterion_noreduction`).\\n\\n        Args:\\n            _input (torch.Tensor | None): The batched input tensor.\\n                If :attr:`_output` is provided, this argument will be ignored.\\n                Defaults to ``None``.\\n            _label (torch.Tensor): The label of the batch with shape ``(N)``.\\n            _output (torch.Tensor | None): The logits of :attr:`_input`.\\n                If ``None``, use :attr:`_input` to calculate logits.\\n                Defaults to ``None``.\\n            reduction (str): Specifies the reduction to apply to the output.\\n                Choose from ``['none', 'mean']``.\\n                Defaults to ``'mean'``.\\n            **kwargs: Keyword arguments passed to :meth:`get_logits()`\\n                if :attr:`_output` is not provided.\\n\\n        Returns:\\n            torch.Tensor:\\n                A scalar loss tensor (with shape ``(N)`` if ``reduction='none'``).\\n        \")), Assign(targets=[Name(id='criterion', ctx=Store())], value=IfExp(test=Compare(left=Name(id='reduction', ctx=Load()), ops=[Eq()], comparators=[Constant(value='none')]), body=Attribute(value=Name(id='self', ctx=Load()), attr='criterion_noreduction', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='criterion', ctx=Load()))), If(test=Compare(left=Name(id='_output', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='_output', ctx=Store())], value=Call(func=Name(id='self', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[]), Return(value=Call(func=Name(id='criterion', ctx=Load()), args=[Name(id='_output', ctx=Load()), Name(id='_label', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='define_optimizer', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='parameters', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Attribute(value=Name(id='nn', ctx=Load()), attr='Parameter', ctx=Load()), ctx=Load()))), arg(arg='OptimType', annotation=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Optimizer', ctx=Load()), ctx=Load()))), arg(arg='lr', annotation=Name(id='float', ctx=Load())), arg(arg='momentum', annotation=Name(id='float', ctx=Load())), arg(arg='weight_decay', annotation=Name(id='float', ctx=Load())), arg(arg='lr_scheduler', annotation=Name(id='bool', ctx=Load())), arg(arg='lr_scheduler_type', annotation=Name(id='str', ctx=Load())), arg(arg='lr_step_size', annotation=Name(id='int', ctx=Load())), arg(arg='lr_gamma', annotation=Name(id='float', ctx=Load())), arg(arg='epochs', annotation=Name(id='int', ctx=Load())), arg(arg='lr_min', annotation=Name(id='float', ctx=Load())), arg(arg='lr_warmup_epochs', annotation=Name(id='int', ctx=Load())), arg(arg='lr_warmup_method', annotation=Name(id='str', ctx=Load())), arg(arg='lr_warmup_decay', annotation=Name(id='float', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value='full'), Constant(value='SGD'), Constant(value=0.1), Constant(value=0.0), Constant(value=0.0), Constant(value=False), Constant(value='CosineAnnealingLR'), Constant(value=30), Constant(value=0.1), Constant(value=None), Constant(value=0.0), Constant(value=0), Constant(value='constant'), Constant(value=0.01)]), body=[Expr(value=Constant(value=\"Define optimizer and lr_scheduler.\\n\\n        Args:\\n            parameters (str | ~collections.abc.Iterable[torch.nn.parameter.Parameter]):\\n                The parameters to optimize while other model parameters are frozen.\\n                If :class:`str`, set :attr:`parameters` as:\\n\\n                    * ``'features': self._model.features``\\n                    * ``'classifier' | 'partial': self._model.classifier``\\n                    * ``'full': self._model``\\n\\n                Defaults to ``'full'``.\\n            OptimType (str | type[Optimizer]):\\n                The optimizer type.\\n                If :class:`str`, load from module :any:`torch.optim`.\\n                Defaults to ``'SGD'``.\\n            lr (float): The learning rate of optimizer. Defaults to ``0.1``.\\n            momentum (float): The momentum of optimizer. Defaults to ``0.0``.\\n            weight_decay (float): The momentum of optimizer. Defaults to ``0.0``.\\n            lr_scheduler (bool): Whether to enable lr_scheduler. Defaults to ``False``.\\n            lr_scheduler_type (str): The type of lr_scheduler.\\n                Defaults to ``'CosineAnnealingLR'``.\\n\\n                Available lr_scheduler types (use string rather than type):\\n\\n                    * :any:`torch.optim.lr_scheduler.StepLR`\\n                    * :any:`torch.optim.lr_scheduler.CosineAnnealingLR`\\n                    * :any:`torch.optim.lr_scheduler.ExponentialLR`\\n            lr_step_size (int): :attr:`step_size` for :any:`torch.optim.lr_scheduler.StepLR`.\\n                Defaults to ``30``.\\n            lr_gamma (float): :attr:`gamma` for :any:`torch.optim.lr_scheduler.StepLR`\\n                or :any:`torch.optim.lr_scheduler.ExponentialLR`.\\n                Defaults to ``0.1``.\\n            epochs (int): Total training epochs.\\n                ``epochs - lr_warmup_epochs`` is passed as :attr:`T_max`\\n                to any:`torch.optim.lr_scheduler.CosineAnnealingLR`.\\n                Defaults to ``None``.\\n            lr_min (float): The minimum of learning rate.\\n                It's passed as :attr:`eta_min`\\n                to any:`torch.optim.lr_scheduler.CosineAnnealingLR`.\\n                Defaults to ``0.0``.\\n            lr_warmup_epochs (int): Learning rate warmup epochs.\\n                Passed as :attr:`total_iters` to lr_scheduler.\\n                Defaults to ``0``.\\n            lr_warmup_method (str): Learning rate warmup methods.\\n                Choose from ``['constant', 'linear']``.\\n                Defaults to ``'constant'``.\\n            lr_warmup_decay (float): Learning rate warmup decay factor.\\n                Passed as :attr:`factor` (:attr:`start_factor`) to lr_scheduler.\\n                Defaults to ``0.01``.\\n            **kwargs: Keyword arguments passed to optimizer init method.\\n\\n        Returns:\\n            (torch.optim.Optimizer, torch.optim.lr_scheduler._LRScheduler):\\n                The tuple of optimizer and lr_scheduler.\\n        \")), Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='momentum'), ctx=Store())], value=Name(id='momentum', ctx=Load())), Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='weight_decay'), ctx=Store())], value=Name(id='weight_decay', ctx=Load())), Match(subject=Name(id='parameters', ctx=Load()), cases=[match_case(pattern=MatchClass(cls=Name(id='str', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Assign(targets=[Name(id='parameters', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_parameter_from_name', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='parameters', ctx=Load()))]))]), match_case(pattern=MatchClass(cls=Name(id='Iterable', ctx=Load()), patterns=[], kwd_attrs=[], kwd_patterns=[]), body=[Pass()]), match_case(pattern=MatchAs(), body=[Raise(exc=Call(func=Name(id='TypeError', ctx=Load()), args=[JoinedStr(values=[Constant(value='type(parameters)='), FormattedValue(value=Call(func=Name(id='type', ctx=Load()), args=[Name(id='parameters', ctx=Load())], keywords=[]), conversion=114), Constant(value='    parameters='), FormattedValue(value=Name(id='parameters', ctx=Load()), conversion=114)])], keywords=[]))])]), If(test=Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='OptimType', ctx=Load()), Name(id='str', ctx=Load())], keywords=[]), body=[AnnAssign(target=Name(id='OptimType', ctx=Store()), annotation=Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Optimizer', ctx=Load()), ctx=Load()), value=Call(func=Name(id='getattr', ctx=Load()), args=[Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), Name(id='OptimType', ctx=Load())], keywords=[]), simple=1)], orelse=[]), Assign(targets=[Name(id='keys', ctx=Store())], value=Attribute(value=Attribute(value=Attribute(value=Name(id='OptimType', ctx=Load()), attr='__init__', ctx=Load()), attr='__code__', ctx=Load()), attr='co_varnames', ctx=Load())), Assign(targets=[Name(id='kwargs', ctx=Store())], value=DictComp(key=Name(id='k', ctx=Load()), value=Name(id='v', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[Compare(left=Name(id='k', ctx=Load()), ops=[In()], comparators=[Name(id='keys', ctx=Load())])], is_async=0)])), Assign(targets=[Name(id='optimizer', ctx=Store())], value=Call(func=Name(id='OptimType', ctx=Load()), args=[Name(id='parameters', ctx=Load()), Name(id='lr', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), AnnAssign(target=Name(id='_lr_scheduler', ctx=Store()), annotation=Name(id='_LRScheduler', ctx=Load()), value=Constant(value=None), simple=1), If(test=Name(id='lr_scheduler', ctx=Load()), body=[AnnAssign(target=Name(id='main_lr_scheduler', ctx=Store()), annotation=Name(id='_LRScheduler', ctx=Load()), simple=1), Match(subject=Name(id='lr_scheduler_type', ctx=Load()), cases=[match_case(pattern=MatchValue(value=Constant(value='StepLR')), body=[Assign(targets=[Name(id='main_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='StepLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='step_size', value=Name(id='lr_step_size', ctx=Load())), keyword(arg='gamma', value=Name(id='lr_gamma', ctx=Load()))]))]), match_case(pattern=MatchValue(value=Constant(value='CosineAnnealingLR')), body=[Assign(targets=[Name(id='main_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='CosineAnnealingLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='T_max', value=BinOp(left=Name(id='epochs', ctx=Load()), op=Sub(), right=Name(id='lr_warmup_epochs', ctx=Load()))), keyword(arg='eta_min', value=Name(id='lr_min', ctx=Load()))]))]), match_case(pattern=MatchValue(value=Constant(value='ExponentialLR')), body=[Assign(targets=[Name(id='main_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='ExponentialLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='gamma', value=Name(id='lr_gamma', ctx=Load()))]))]), match_case(pattern=MatchAs(), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid lr_scheduler_type='), FormattedValue(value=Name(id='lr_scheduler_type', ctx=Load()), conversion=114), Constant(value='.Only \"StepLR\", \"CosineAnnealingLR\" and \"ExponentialLR\" are supported.')])], keywords=[]))])]), If(test=Compare(left=Name(id='lr_warmup_epochs', ctx=Load()), ops=[Gt()], comparators=[Constant(value=0)]), body=[Match(subject=Name(id='lr_warmup_method', ctx=Load()), cases=[match_case(pattern=MatchValue(value=Constant(value='linear')), body=[Assign(targets=[Name(id='warmup_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='LinearLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='start_factor', value=Name(id='lr_warmup_decay', ctx=Load())), keyword(arg='total_iters', value=Name(id='lr_warmup_epochs', ctx=Load()))]))]), match_case(pattern=MatchValue(value=Constant(value='constant')), body=[Assign(targets=[Name(id='warmup_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='ConstantLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='factor', value=Name(id='lr_warmup_decay', ctx=Load())), keyword(arg='total_iters', value=Name(id='lr_warmup_epochs', ctx=Load()))]))]), match_case(pattern=MatchAs(), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Constant(value='Invalid lr_warmup_method='), FormattedValue(value=Name(id='lr_warmup_method', ctx=Load()), conversion=114), Constant(value='.Only \"linear\" and \"constant\" are supported.')])], keywords=[]))])]), Assign(targets=[Name(id='_lr_scheduler', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='optim', ctx=Load()), attr='lr_scheduler', ctx=Load()), attr='SequentialLR', ctx=Load()), args=[Name(id='optimizer', ctx=Load())], keywords=[keyword(arg='schedulers', value=List(elts=[Name(id='warmup_lr_scheduler', ctx=Load()), Name(id='main_lr_scheduler', ctx=Load())], ctx=Load())), keyword(arg='milestones', value=List(elts=[Name(id='lr_warmup_epochs', ctx=Load())], ctx=Load()))]))], orelse=[Assign(targets=[Name(id='_lr_scheduler', ctx=Store())], value=Name(id='main_lr_scheduler', ctx=Load()))])], orelse=[]), Return(value=Tuple(elts=[Name(id='optimizer', ctx=Load()), Name(id='_lr_scheduler', ctx=Load())], ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='Optimizer', ctx=Load()), Name(id='_LRScheduler', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='define_criterion', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Define criterion to calculate loss.\\n        Defaults to use :any:`torch.nn.CrossEntropyLoss`.\\n\\n        Args:\\n            weight (torch.Tensor | None):\\n                The loss weights passed to :any:`torch.nn.CrossEntropyLoss`.\\n                Defaults to :attr:`self.loss_weights`.\\n            **kwargs: Keyword arguments passed to :any:`torch.nn.CrossEntropyLoss`.\\n        ')), If(test=Compare(left=Constant(value='weight'), ops=[NotIn()], comparators=[Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='weight'), ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='loss_weights', ctx=Load()))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='CrossEntropyLoss', ctx=Load()), args=[], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='nn', ctx=Load()), attr='CrossEntropyLoss', ctx=Load())), FunctionDef(name='load', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='file_path', annotation=Name(id='str', ctx=Load())), arg(arg='folder_path', annotation=Name(id='str', ctx=Load())), arg(arg='suffix', annotation=Name(id='str', ctx=Load())), arg(arg='inplace', annotation=Name(id='bool', ctx=Load())), arg(arg='map_location', annotation=BinOp(left=BinOp(left=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Name(id='Callable', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='torch', ctx=Load()), attr='device', ctx=Load())), op=BitOr(), right=Name(id='dict', ctx=Load()))), arg(arg='component', annotation=Name(id='str', ctx=Load())), arg(arg='strict', annotation=Name(id='bool', ctx=Load())), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=True), Constant(value='cpu'), Constant(value='full'), Constant(value=True), Constant(value=False), Constant(value=0)]), body=[Expr(value=Constant(value=\"Load pretrained model weights.\\n\\n        Args:\\n            file_path (str | None): The file path to load pretrained weights.\\n                If ``'official'``, call :meth:`get_official_weights()`.\\n                Defaults to ``'{folder_path}/{self.name}{suffix}.pth'``.\\n            folder_path (str | None): The folder path containing model checkpoint.\\n                It is used when :attr:`file_path` is not provided.\\n                Defaults to :attr:`self.folder_path`.\\n            suffix (str | None): The suffix string to model weights file.\\n                Defaults to :attr:`self.suffix`.\\n            inplace (bool): Whether to change model parameters.\\n                If ``False``, will only return the dict but not change model parameters.\\n                Defaults to ``True``.\\n            map_location (str | ~torch.torch.device | dict):\\n                Passed to :any:`torch.load`.\\n                Defaults to ``'cpu'``.\\n\\n                Note:\\n                    The device of model parameters will still be ``'cuda'``\\n                    if there is any cuda available.\\n                    This argument only affects intermediate operation.\\n            component (str): Specify which part of the weights to load.\\n                Choose from ``['full', 'features', 'classifier']``.\\n                Defaults to ``'full'``.\\n            strict (bool): Passed to :any:`torch.nn.Module.load_state_dict`.\\n                Defaults to ``True``.\\n            verbose (bool): Whether to output auxiliary information.\\n                Defaults to ``False``.\\n            indent (int): The indent of output auxialiary information.\\n            **kwargs: Keyword arguments passed to :any:`torch.load`.\\n\\n        Returns:\\n            OrderedDict[str, torch.Tensor]: The model weights OrderedDict.\\n        \")), Assign(targets=[Name(id='map_location', ctx=Store())], value=IfExp(test=Compare(left=Name(id='map_location', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='default')]), body=Name(id='map_location', ctx=Load()), orelse=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='device'), ctx=Load()))), If(test=Compare(left=Name(id='file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='folder_path', ctx=Store())], value=IfExp(test=Compare(left=Name(id='folder_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='folder_path', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='folder_path', ctx=Load()))), Assign(targets=[Name(id='suffix', ctx=Store())], value=IfExp(test=Compare(left=Name(id='suffix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='suffix', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='suffix', ctx=Load()))), Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='suffix', ctx=Load()), conversion=-1), Constant(value='.pth')])], keywords=[])], keywords=[]))], orelse=[]), If(test=Compare(left=Name(id='file_path', ctx=Load()), ops=[Eq()], comparators=[Constant(value='official')]), body=[Assign(targets=[Name(id='_dict', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_official_weights', ctx=Load()), args=[], keywords=[keyword(arg='map_location', value=Name(id='map_location', ctx=Load()))])), Assign(targets=[Name(id='last_bias_value', ctx=Store())], value=Call(func=Name(id='next', ctx=Load()), args=[Call(func=Name(id='reversed', ctx=Load()), args=[Call(func=Attribute(value=Name(id='_dict', ctx=Load()), attr='values', ctx=Load()), args=[], keywords=[])], keywords=[])], keywords=[])), If(test=BoolOp(op=And(), values=[Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='num_classes', ctx=Load()), ops=[NotEq()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='last_bias_value', ctx=Load())], keywords=[])]), Compare(left=Name(id='component', ctx=Load()), ops=[NotEq()], comparators=[Constant(value='features')])]), body=[Assign(targets=[Name(id='strict', ctx=Store())], value=Constant(value=False)), Expr(value=Call(func=Attribute(value=Name(id='_dict', ctx=Load()), attr='popitem', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Name(id='_dict', ctx=Load()), attr='popitem', ctx=Load()), args=[], keywords=[]))], orelse=[])], orelse=[Try(body=[AnnAssign(target=Name(id='_dict', ctx=Store()), annotation=Subscript(value=Name(id='OrderedDict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='load', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[keyword(arg='map_location', value=Name(id='map_location', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]), simple=1)], handlers=[ExceptHandler(type=Name(id='Exception', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[Constant(value='file_path='), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=114)])], keywords=[])), Raise()])], orelse=[], finalbody=[])]), Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())), Match(subject=Name(id='component', ctx=Load()), cases=[match_case(pattern=MatchValue(value=Constant(value='features')), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='features', ctx=Load())), Assign(targets=[Name(id='_dict', ctx=Store())], value=Call(func=Name(id='OrderedDict', ctx=Load()), args=[ListComp(elt=Tuple(elts=[Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='removeprefix', ctx=Load()), args=[Constant(value='features.')], keywords=[]), Name(id='value', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))]), match_case(pattern=MatchValue(value=Constant(value='classifier')), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='classifier', ctx=Load())), Assign(targets=[Name(id='_dict', ctx=Store())], value=Call(func=Name(id='OrderedDict', ctx=Load()), args=[ListComp(elt=Tuple(elts=[Call(func=Attribute(value=Name(id='key', ctx=Load()), attr='removeprefix', ctx=Load()), args=[Constant(value='classifier.')], keywords=[]), Name(id='value', ctx=Load())], ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='key', ctx=Store()), Name(id='value', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)])], keywords=[]))]), match_case(pattern=MatchAs(), body=[Assert(test=Compare(left=Name(id='component', ctx=Load()), ops=[Eq()], comparators=[Constant(value='full')]), msg=JoinedStr(values=[Constant(value='component='), FormattedValue(value=Name(id='component', ctx=Load()), conversion=114)]))])]), If(test=Name(id='inplace', ctx=Load()), body=[Try(body=[Expr(value=Call(func=Attribute(value=Name(id='module', ctx=Load()), attr='load_state_dict', ctx=Load()), args=[Name(id='_dict', ctx=Load())], keywords=[keyword(arg='strict', value=Name(id='strict', ctx=Load()))]))], handlers=[ExceptHandler(type=Name(id='RuntimeError', ctx=Load()), body=[Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[JoinedStr(values=[Constant(value='Model '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=' loaded from: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='indent', value=Name(id='indent', ctx=Load()))])), Raise()])], orelse=[], finalbody=[])], orelse=[]), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[JoinedStr(values=[Constant(value='Model '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=' loaded from: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='indent', value=Name(id='indent', ctx=Load()))]))], orelse=[]), If(test=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='num_gpus'), ctx=Load()), body=[Expr(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='cuda', ctx=Load()), args=[], keywords=[]))], orelse=[]), Return(value=Name(id='_dict', ctx=Load()))], decorator_list=[Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='no_grad', ctx=Load()), args=[], keywords=[])], returns=Subscript(value=Name(id='OrderedDict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='save', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='file_path', annotation=Name(id='str', ctx=Load())), arg(arg='folder_path', annotation=Name(id='str', ctx=Load())), arg(arg='suffix', annotation=Name(id='str', ctx=Load())), arg(arg='component', annotation=Name(id='str', ctx=Load())), arg(arg='_epoch', annotation=BinOp(left=Name(id='int', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=''), Constant(value=None), Constant(value=False), Constant(value=0)]), body=[Expr(value=Constant(value=\"Save pretrained model weights.\\n\\n        Args:\\n            file_path (str | None): The file path to save pretrained weights.\\n                Defaults to ``'{folder_path}/{self.name}{suffix}.pth'``.\\n            folder_path (str | None): The folder path containing model checkpoint.\\n                It is used when :attr:`file_path` is not provided.\\n                Defaults to :attr:`self.folder_path`.\\n            suffix (str | None): The suffix string to model weights file.\\n                Defaults to :attr:`self.suffix`.\\n            component (str): Specify which part of the weights to save.\\n                Choose from ``['full', 'features', 'classifier']``.\\n                Defaults to ``'full'``.\\n            verbose (bool): Whether to output auxiliary information.\\n                Defaults to ``False``.\\n            indent (int): The indent of output auxialiary information.\\n            **kwargs: Keyword arguments passed to :any:`torch.save`.\\n        \")), If(test=Compare(left=Name(id='file_path', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='folder_path', ctx=Store())], value=IfExp(test=Compare(left=Name(id='folder_path', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='folder_path', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='folder_path', ctx=Load()))), Assign(targets=[Name(id='suffix', ctx=Store())], value=IfExp(test=Compare(left=Name(id='suffix', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='suffix', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='suffix', ctx=Load()))), Assign(targets=[Name(id='file_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='normpath', ctx=Load()), args=[Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Name(id='folder_path', ctx=Load()), JoinedStr(values=[FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), FormattedValue(value=Name(id='suffix', ctx=Load()), conversion=-1), Constant(value='.pth')])], keywords=[])], keywords=[]))], orelse=[Assign(targets=[Name(id='folder_path', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='dirname', ctx=Load()), args=[Name(id='file_path', ctx=Load())], keywords=[]))]), If(test=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='exists', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[])), body=[Expr(value=Call(func=Attribute(value=Name(id='os', ctx=Load()), attr='makedirs', ctx=Load()), args=[Name(id='folder_path', ctx=Load())], keywords=[]))], orelse=[]), Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())), If(test=Compare(left=Name(id='component', ctx=Load()), ops=[Eq()], comparators=[Constant(value='features')]), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='features', ctx=Load()))], orelse=[If(test=Compare(left=Name(id='component', ctx=Load()), ops=[Eq()], comparators=[Constant(value='classifier')]), body=[Assign(targets=[Name(id='module', ctx=Store())], value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='classifier', ctx=Load()))], orelse=[Assert(test=Compare(left=Name(id='component', ctx=Load()), ops=[Eq()], comparators=[Constant(value='')]), msg=JoinedStr(values=[Constant(value='component='), FormattedValue(value=Name(id='component', ctx=Load()), conversion=114)]))])]), AnnAssign(target=Name(id='_dict', ctx=Store()), annotation=Subscript(value=Name(id='OrderedDict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load()), value=Call(func=Attribute(value=Name(id='module', ctx=Load()), attr='state_dict', ctx=Load()), args=[], keywords=[keyword(arg='prefix', value=Name(id='component', ctx=Load()))]), simple=1), Expr(value=Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='save', ctx=Load()), args=[Name(id='_dict', ctx=Load()), Name(id='file_path', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), If(test=Name(id='verbose', ctx=Load()), body=[Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[JoinedStr(values=[Constant(value='Model '), FormattedValue(value=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), conversion=-1), Constant(value=' saved at: '), FormattedValue(value=Name(id='file_path', ctx=Load()), conversion=-1)])], keywords=[keyword(arg='indent', value=Name(id='indent', ctx=Load()))]))], orelse=[])], decorator_list=[Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='no_grad', ctx=Load()), args=[], keywords=[])]), FunctionDef(name='get_official_weights', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='weights', annotation=BinOp(left=Name(id='WeightsEnum', ctx=Load()), op=BitOr(), right=Constant(value=None))), arg(arg='progress', annotation=Name(id='bool', ctx=Load())), arg(arg='map_location', annotation=BinOp(left=BinOp(left=BinOp(left=Name(id='str', ctx=Load()), op=BitOr(), right=Name(id='Callable', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='torch', ctx=Load()), attr='device', ctx=Load())), op=BitOr(), right=Name(id='dict', ctx=Load())))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=True), Constant(value='cpu')]), body=[Expr(value=Constant(value=\"Get official model weights from :attr:`weights`.\\n\\n        Args:\\n            weights (~torchvision.models._api.WeightsEnum | None):\\n                The pretrained weights to use.\\n                Defaults to :attr:`self.weights[self.name]`.\\n            map_location (str | ~torch.torch.device | dict):\\n                Passed to :any:`torch.hub.load_state_dict_from_url`.\\n                Defaults to ``'cpu'``.\\n            **kwargs: Keyword arguments passed to\\n                :any:`torch.hub.load_state_dict_from_url`.\\n\\n        Returns:\\n            OrderedDict[str, torch.Tensor]: The model weights OrderedDict.\\n        \")), If(test=Compare(left=Name(id='weights', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='weights', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Subscript(value=Attribute(value=Name(id='self', ctx=Load()), attr='weights', ctx=Load()), slice=Attribute(value=Name(id='self', ctx=Load()), attr='name', ctx=Load()), ctx=Load()), Constant(value='DEFAULT')], keywords=[]))], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='weights', ctx=Load()), attr='get_state_dict', ctx=Load()), args=[], keywords=[keyword(arg='progress', value=Name(id='progress', ctx=Load())), keyword(arg='check_hash', value=Constant(value=True)), keyword(arg='map_location', value=Name(id='map_location', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='OrderedDict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_train', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='epochs', annotation=Name(id='int', ctx=Load())), arg(arg='optimizer', annotation=Name(id='Optimizer', ctx=Load())), arg(arg='module', annotation=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load())), arg(arg='lr_scheduler', annotation=Name(id='_LRScheduler', ctx=Load())), arg(arg='lr_warmup_epochs', annotation=Name(id='int', ctx=Load())), arg(arg='model_ema', annotation=Name(id='ExponentialMovingAverage', ctx=Load())), arg(arg='model_ema_steps', annotation=Name(id='int', ctx=Load())), arg(arg='grad_clip', annotation=Name(id='float', ctx=Load())), arg(arg='pre_conditioner', annotation=BinOp(left=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='KFAC', ctx=Load())), op=BitOr(), right=Name(id='EKFAC', ctx=Load()))), arg(arg='print_prefix', annotation=Name(id='str', ctx=Load())), arg(arg='start_epoch', annotation=Name(id='int', ctx=Load())), arg(arg='resume', annotation=Name(id='int', ctx=Load())), arg(arg='validate_interval', annotation=Name(id='int', ctx=Load())), arg(arg='save', annotation=Name(id='bool', ctx=Load())), arg(arg='amp', annotation=Name(id='bool', ctx=Load())), arg(arg='loader_train', annotation=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='utils', ctx=Load()), attr='data', ctx=Load()), attr='DataLoader', ctx=Load())), arg(arg='loader_valid', annotation=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='utils', ctx=Load()), attr='data', ctx=Load()), attr='DataLoader', ctx=Load())), arg(arg='epoch_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Constant(value=None)], ctx=Load()), ctx=Load())), arg(arg='get_data_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='loss_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='after_loss_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Constant(value=None)], ctx=Load()), ctx=Load())), arg(arg='validate_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='save_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Constant(value=None)], ctx=Load()), ctx=Load())), arg(arg='file_path', annotation=Name(id='str', ctx=Load())), arg(arg='folder_path', annotation=Name(id='str', ctx=Load())), arg(arg='suffix', annotation=Name(id='str', ctx=Load())), arg(arg='writer'), arg(arg='main_tag', annotation=Name(id='str', ctx=Load())), arg(arg='tag', annotation=Name(id='str', ctx=Load())), arg(arg='metric_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=0), Constant(value=None), Constant(value=32), Constant(value=None), Constant(value=None), Constant(value='Train'), Constant(value=0), Constant(value=0), Constant(value=10), Constant(value=False), Constant(value=False), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='train'), Constant(value=''), Constant(value=None), Constant(value=True), Constant(value=0)]), body=[Expr(value=Constant(value='Train the model')), Assign(targets=[Name(id='module', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='module', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())])), Assign(targets=[Name(id='num_classes', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='num_classes', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='num_classes', ctx=Load())])), Assign(targets=[Name(id='loader_train', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loader_train', ctx=Load()), Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Load()), attr='loader', ctx=Load()), slice=Constant(value='train'), ctx=Load())])), Assign(targets=[Name(id='get_data_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='get_data_fn', ctx=Load())], keywords=[]), body=Name(id='get_data_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='get_data', ctx=Load()))), Assign(targets=[Name(id='loss_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='loss_fn', ctx=Load())], keywords=[]), body=Name(id='loss_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='loss', ctx=Load()))), Assign(targets=[Name(id='validate_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='validate_fn', ctx=Load())], keywords=[]), body=Name(id='validate_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='_validate', ctx=Load()))), Assign(targets=[Name(id='save_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='save_fn', ctx=Load())], keywords=[]), body=Name(id='save_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='save', ctx=Load()))), Assign(targets=[Name(id='metric_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='metric_fn', ctx=Load())], keywords=[]), body=Name(id='metric_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='accuracy', ctx=Load()))), Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='forward_fn'), ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='forward_fn'), Attribute(value=Name(id='self', ctx=Load()), attr='__call__', ctx=Load())], keywords=[])), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='epoch_fn', ctx=Load())], keywords=[])), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='epoch_fn')], keywords=[])]), body=[Assign(targets=[Name(id='epoch_fn', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='epoch_fn')], keywords=[]))], orelse=[]), If(test=BoolOp(op=And(), values=[UnaryOp(op=Not(), operand=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='after_loss_fn', ctx=Load())], keywords=[])), Call(func=Name(id='hasattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='after_loss_fn')], keywords=[])]), body=[Assign(targets=[Name(id='after_loss_fn', ctx=Store())], value=Call(func=Name(id='getattr', ctx=Load()), args=[Name(id='self', ctx=Load()), Constant(value='after_loss_fn')], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='train', ctx=Load()), args=[], keywords=[keyword(arg='module', value=Name(id='module', ctx=Load())), keyword(arg='num_classes', value=Name(id='num_classes', ctx=Load())), keyword(arg='epochs', value=Name(id='epochs', ctx=Load())), keyword(arg='optimizer', value=Name(id='optimizer', ctx=Load())), keyword(arg='lr_scheduler', value=Name(id='lr_scheduler', ctx=Load())), keyword(arg='lr_warmup_epochs', value=Name(id='lr_warmup_epochs', ctx=Load())), keyword(arg='model_ema', value=Name(id='model_ema', ctx=Load())), keyword(arg='model_ema_steps', value=Name(id='model_ema_steps', ctx=Load())), keyword(arg='grad_clip', value=Name(id='grad_clip', ctx=Load())), keyword(arg='pre_conditioner', value=Name(id='pre_conditioner', ctx=Load())), keyword(arg='print_prefix', value=Name(id='print_prefix', ctx=Load())), keyword(arg='start_epoch', value=Name(id='start_epoch', ctx=Load())), keyword(arg='resume', value=Name(id='resume', ctx=Load())), keyword(arg='validate_interval', value=Name(id='validate_interval', ctx=Load())), keyword(arg='save', value=Name(id='save', ctx=Load())), keyword(arg='amp', value=Name(id='amp', ctx=Load())), keyword(arg='loader_train', value=Name(id='loader_train', ctx=Load())), keyword(arg='loader_valid', value=Name(id='loader_valid', ctx=Load())), keyword(arg='epoch_fn', value=Name(id='epoch_fn', ctx=Load())), keyword(arg='get_data_fn', value=Name(id='get_data_fn', ctx=Load())), keyword(arg='loss_fn', value=Name(id='loss_fn', ctx=Load())), keyword(arg='after_loss_fn', value=Name(id='after_loss_fn', ctx=Load())), keyword(arg='validate_fn', value=Name(id='validate_fn', ctx=Load())), keyword(arg='save_fn', value=Name(id='save_fn', ctx=Load())), keyword(arg='file_path', value=Name(id='file_path', ctx=Load())), keyword(arg='folder_path', value=Name(id='folder_path', ctx=Load())), keyword(arg='suffix', value=Name(id='suffix', ctx=Load())), keyword(arg='writer', value=Name(id='writer', ctx=Load())), keyword(arg='main_tag', value=Name(id='main_tag', ctx=Load())), keyword(arg='tag', value=Name(id='tag', ctx=Load())), keyword(arg='metric_fn', value=Name(id='metric_fn', ctx=Load())), keyword(arg='verbose', value=Name(id='verbose', ctx=Load())), keyword(arg='indent', value=Name(id='indent', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='_validate', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='module', annotation=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())), arg(arg='num_classes', annotation=Name(id='int', ctx=Load())), arg(arg='loader', annotation=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='utils', ctx=Load()), attr='data', ctx=Load()), attr='DataLoader', ctx=Load())), arg(arg='print_prefix', annotation=Name(id='str', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load())), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='get_data_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='loss_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='writer'), arg(arg='main_tag', annotation=Name(id='str', ctx=Load())), arg(arg='tag', annotation=Name(id='str', ctx=Load())), arg(arg='_epoch', annotation=Name(id='int', ctx=Load())), arg(arg='metric_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='Validate'), Constant(value=0), Constant(value=True), Constant(value=None), Constant(value=None), Constant(value=None), Constant(value='valid'), Constant(value=''), Constant(value=None), Constant(value=None)]), body=[Expr(value=Constant(value='Evaluate the model.\\n\\n        Returns:\\n            (float, float): Accuracy and loss.\\n        ')), Assign(targets=[Name(id='module', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='module', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())])), Assign(targets=[Name(id='num_classes', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='num_classes', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='num_classes', ctx=Load())])), Assign(targets=[Name(id='loader', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loader', ctx=Load()), Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Load()), attr='loader', ctx=Load()), slice=Constant(value='valid'), ctx=Load())])), Assign(targets=[Name(id='get_data_fn', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='get_data_fn', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='get_data', ctx=Load())])), Assign(targets=[Name(id='loss_fn', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loss_fn', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='loss', ctx=Load())])), Assign(targets=[Name(id='metric_fn', ctx=Store())], value=IfExp(test=Call(func=Name(id='callable', ctx=Load()), args=[Name(id='metric_fn', ctx=Load())], keywords=[]), body=Name(id='metric_fn', ctx=Load()), orelse=Attribute(value=Name(id='self', ctx=Load()), attr='accuracy', ctx=Load()))), Assign(targets=[Subscript(value=Name(id='kwargs', ctx=Load()), slice=Constant(value='forward_fn'), ctx=Store())], value=Call(func=Attribute(value=Name(id='kwargs', ctx=Load()), attr='get', ctx=Load()), args=[Constant(value='forward_fn'), Attribute(value=Name(id='self', ctx=Load()), attr='__call__', ctx=Load())], keywords=[])), Return(value=Call(func=Name(id='validate', ctx=Load()), args=[], keywords=[keyword(arg='module', value=Name(id='module', ctx=Load())), keyword(arg='num_classes', value=Name(id='num_classes', ctx=Load())), keyword(arg='loader', value=Name(id='loader', ctx=Load())), keyword(arg='print_prefix', value=Name(id='print_prefix', ctx=Load())), keyword(arg='indent', value=Name(id='indent', ctx=Load())), keyword(arg='verbose', value=Name(id='verbose', ctx=Load())), keyword(arg='get_data_fn', value=Name(id='get_data_fn', ctx=Load())), keyword(arg='loss_fn', value=Name(id='loss_fn', ctx=Load())), keyword(arg='writer', value=Name(id='writer', ctx=Load())), keyword(arg='main_tag', value=Name(id='main_tag', ctx=Load())), keyword(arg='tag', value=Name(id='tag', ctx=Load())), keyword(arg='_epoch', value=Name(id='_epoch', ctx=Load())), keyword(arg='metric_fn', value=Name(id='metric_fn', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='_compare', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='peer', annotation=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())), arg(arg='loader', annotation=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='utils', ctx=Load()), attr='data', ctx=Load()), attr='DataLoader', ctx=Load())), arg(arg='print_prefix', annotation=Name(id='str', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load())), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='get_data_fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[Constant(value=Ellipsis), Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='criterion', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value='Validate'), Constant(value=0), Constant(value=True), Constant(value=None), Constant(value=None)]), body=[Assign(targets=[Name(id='loader', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='loader', ctx=Load()), Subscript(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Load()), attr='loader', ctx=Load()), slice=Constant(value='valid'), ctx=Load())])), Assign(targets=[Name(id='get_data_fn', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='get_data_fn', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='get_data', ctx=Load())])), Assign(targets=[Name(id='criterion', ctx=Store())], value=BoolOp(op=Or(), values=[Name(id='criterion', ctx=Load()), Attribute(value=Name(id='self', ctx=Load()), attr='criterion', ctx=Load())])), Return(value=Call(func=Name(id='compare', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='peer', ctx=Load()), Name(id='loader', ctx=Load()), Name(id='print_prefix', ctx=Load()), Name(id='indent', ctx=Load()), Name(id='verbose', ctx=Load()), Name(id='get_data_fn', ctx=Load())], keywords=[keyword(arg='criterion', value=Attribute(value=Name(id='self', ctx=Load()), attr='criterion', ctx=Load())), keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='float', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_data', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='data')], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Process data. Defaults to be :attr:`self.dataset.get_data`.\\n        If :attr:`self.dataset` is ``None``, return :attr:`data` directly.\\n\\n        Args:\\n            data (Any): Unprocessed data.\\n            **kwargs: Keyword arguments passed to\\n                :attr:`self.dataset.get_data()`.\\n\\n        Returns:\\n            Any: Processed data.\\n        ')), If(test=Compare(left=Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='dataset', ctx=Load()), attr='get_data', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], orelse=[Return(value=Name(id='data', ctx=Load()))])], decorator_list=[]), FunctionDef(name='accuracy', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_output', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='_label', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='topk', annotation=Subscript(value=Name(id='Iterable', ctx=Load()), slice=Name(id='int', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Tuple(elts=[Constant(value=1), Constant(value=5)], ctx=Load())]), body=[Expr(value=Constant(value='Computes the accuracy over the k top predictions\\n        for the specified values of k.\\n\\n        Args:\\n            _output (torch.Tensor): The batched logit tensor with shape ``(N, C)``.\\n            _label (torch.Tensor): The batched label tensor with shape ``(N)``.\\n            topk (~collections.abc.Iterable[int]): Which top-k accuracies to show.\\n                Defaults to ``(1, 5)``.\\n            **kwargs: Keyword arguments passed to :func:`trojanzoo.utils.model.accuracy`.\\n\\n        Returns:\\n            dict[str, float]: Top-k accuracies.\\n\\n        Note:\\n            The implementation is in :func:`trojanzoo.utils.model.accuracy`.\\n        ')), Return(value=Call(func=Name(id='accuracy', ctx=Load()), args=[Name(id='_output', ctx=Load()), Name(id='_label', ctx=Load()), Name(id='topk', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Name(id='float', ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='activate_params', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='params', annotation=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Attribute(value=Name(id='nn', ctx=Load()), attr='Parameter', ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[List(elts=[], ctx=Load())]), body=[Expr(value=Constant(value='Set ``requires_grad=True`` for selected :attr:`params` of :attr:`module`.\\n        All other params are frozen.\\n\\n        Args:\\n            params (~collections.abc.Iterator[torch.nn.parameter.Parameter]):\\n                The parameters to ``requires_grad``.\\n                Defaults to ``[]``.\\n        ')), Return(value=Call(func=Name(id='activate_params', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), Name(id='params', ctx=Load())], keywords=[]))], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_parallel_model', args=arguments(posonlyargs=[], args=[arg(arg='_model', annotation=Name(id='_Model', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Get the parallel model if there are more than 1 GPU avaiable.\\n\\n        Warning:\\n            :any:`torch.nn.DataParallel` would be deprecated according to\\n            https://github.com/pytorch/pytorch/issues/65936.\\n            We need to consider using\\n            :any:`torch.nn.parallel.DistributedDataParallel` instead.\\n\\n        Args:\\n            _model (_Model): The non-parallel model.\\n        Returns:\\n            _Model | nn.DataParallel: The parallel model if there are more than 1 GPU avaiable.\\n        ')), If(test=Compare(left=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='num_gpus'), ctx=Load()), ops=[Gt()], comparators=[Constant(value=1)]), body=[Return(value=Call(func=Attribute(value=Name(id='nn', ctx=Load()), attr='DataParallel', ctx=Load()), args=[Name(id='_model', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Name(id='_model', ctx=Load()))], decorator_list=[Name(id='staticmethod', ctx=Load())], returns=BinOp(left=Name(id='_Model', ctx=Load()), op=BitOr(), right=Attribute(value=Name(id='nn', ctx=Load()), attr='DataParallel', ctx=Load()))), FunctionDef(name='summary', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='depth', annotation=Name(id='int', ctx=Load())), arg(arg='verbose', annotation=Name(id='bool', ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=True), Constant(value=0)]), body=[Expr(value=Constant(value=\"Prints a string summary of the model instance by calling\\n        :func:`trojanzoo.utils.module.BasicObject.summary()`\\n        and :func:`trojanzoo.utils.model.summary()`.\\n\\n        Args:\\n            depth (int): Passed to :func:`trojanzoo.utils.model.summary()`.\\n                If ``None``, set as ``env['verbose']``.\\n                If still ``None``, set as ``1``.\\n                Defaults to ``None``.\\n            verbose (bool): Passed to :func:`trojanzoo.utils.model.summary()`.\\n                Defaults to ``True``.\\n            indent (int): Passed to :func:`trojanzoo.utils.module.BasicObject.summary()`\\n                and passed to :func:`trojanzoo.utils.model.summary()` with ``10`` more.\\n                Defaults to ``0``.\\n            **kwargs: Passed to :func:`trojanzoo.utils.model.summary()`.\\n        \")), Expr(value=Call(func=Attribute(value=Call(func=Name(id='super', ctx=Load()), args=[], keywords=[]), attr='summary', ctx=Load()), args=[], keywords=[keyword(arg='indent', value=Name(id='indent', ctx=Load()))])), If(test=Compare(left=Name(id='depth', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='depth', ctx=Store())], value=Subscript(value=Name(id='env', ctx=Load()), slice=Constant(value='verbose'), ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='depth', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='depth', ctx=Store())], value=Constant(value=1))], orelse=[]), Expr(value=Call(func=Name(id='summary', ctx=Load()), args=[Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load())], keywords=[keyword(arg='depth', value=Name(id='depth', ctx=Load())), keyword(arg='verbose', value=Name(id='verbose', ctx=Load())), keyword(arg='indent', value=BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Constant(value=10))), keyword(value=Name(id='kwargs', ctx=Load()))])), Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[BinOp(left=Constant(value='-'), op=Mult(), right=Constant(value=20))], keywords=[keyword(arg='indent', value=BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Constant(value=10)))]))], decorator_list=[]), FunctionDef(name='train', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='mode', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Sets the module in training mode.\\n\\n        See Also:\\n            :any:`torch.nn.Module.train`.\\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='train', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='train', ctx=Load()), args=[], keywords=[keyword(arg='mode', value=Name(id='mode', ctx=Load()))])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Self', ctx=Load())), FunctionDef(name='eval', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Sets the module in evaluation mode.\\n\\n        See Also:\\n            :any:`torch.nn.Module.eval`.\\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='eval', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Self', ctx=Load())), FunctionDef(name='cpu', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Moves all model parameters and buffers to the CPU.\\n\\n        See Also:\\n            :any:`torch.nn.Module.cpu`.\\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='cpu', ctx=Load()), args=[], keywords=[])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='cpu', ctx=Load()), args=[], keywords=[])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Self', ctx=Load())), FunctionDef(name='cuda', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='device', annotation=BinOp(left=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='int', ctx=Load())), op=BitOr(), right=Attribute(value=Name(id='torch', ctx=Load()), attr='device', ctx=Load())))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None)]), body=[Expr(value=Constant(value='Moves all model parameters and buffers to the GPU.\\n\\n        See Also:\\n            :any:`torch.nn.Module.cuda`.\\n        ')), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='cuda', ctx=Load()), args=[], keywords=[keyword(arg='device', value=Name(id='device', ctx=Load()))])), Expr(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='model', ctx=Load()), attr='cuda', ctx=Load()), args=[], keywords=[keyword(arg='device', value=Name(id='device', ctx=Load()))])), Return(value=Name(id='self', ctx=Load()))], decorator_list=[], returns=Name(id='Self', ctx=Load())), FunctionDef(name='zero_grad', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='set_to_none', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=False)]), body=[Expr(value=Constant(value='Sets gradients of all model parameters to zero.\\n\\n        See Also:\\n            :any:`torch.nn.Module.zero_grad`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='zero_grad', ctx=Load()), args=[], keywords=[keyword(arg='set_to_none', value=Name(id='set_to_none', ctx=Load()))]))], decorator_list=[], returns=Name(id='Self', ctx=Load())), FunctionDef(name='state_dict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='destination', annotation=Subscript(value=Name(id='Mapping', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='prefix', annotation=Name(id='str', ctx=Load())), arg(arg='keep_vars', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=''), Constant(value=False)]), body=[Expr(value=Constant(value='Returns a dictionary containing a whole state of the module.\\n\\n        See Also:\\n            :any:`torch.nn.Module.state_dict`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='state_dict', ctx=Load()), args=[], keywords=[keyword(arg='destination', value=Name(id='destination', ctx=Load())), keyword(arg='prefix', value=Name(id='prefix', ctx=Load())), keyword(arg='keep_vars', value=Name(id='keep_vars', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='load_state_dict', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='state_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='strict', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Copies parameters and buffers from :attr:`state_dict`\\n        into this module and its descendants.\\n\\n        See Also:\\n            :any:`torch.nn.Module.load_state_dict`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='load_state_dict', ctx=Load()), args=[Name(id='state_dict', ctx=Load())], keywords=[keyword(arg='strict', value=Name(id='strict', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='parameters', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='recurse', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Returns an iterator over module parameters.\\n\\n        See Also:\\n            :any:`torch.nn.Module.parameters`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='parameters', ctx=Load()), args=[], keywords=[keyword(arg='recurse', value=Name(id='recurse', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='named_parameters', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='prefix'), arg(arg='recurse')], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=''), Constant(value=True)]), body=[Expr(value=Constant(value='Returns an iterator over module parameters, yielding both the\\n        name of the parameter as well as the parameter itself.\\n\\n        See Also:\\n            :any:`torch.nn.Module.named_parameters`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='named_parameters', ctx=Load()), args=[], keywords=[keyword(arg='prefix', value=Name(id='prefix', ctx=Load())), keyword(arg='recurse', value=Name(id='recurse', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='children', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an iterator over immediate children modules.\\n\\n        See Also:\\n            :any:`torch.nn.Module.children`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='children', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='named_children', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an iterator over immediate children modules, yielding both\\n        the name of the module as well as the module itself.\\n\\n        See Also:\\n            :any:`torch.nn.Module.named_children`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='named_children', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='modules', args=arguments(posonlyargs=[], args=[arg(arg='self')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Returns an iterator over all modules in the network.\\n\\n        See Also:\\n            :any:`torch.nn.Module.modules`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='modules', ctx=Load()), args=[], keywords=[]))], decorator_list=[]), FunctionDef(name='named_modules', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='memo', annotation=BinOp(left=Constant(value=None), op=BitOr(), right=Subscript(value=Name(id='set', ctx=Load()), slice=Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load()), ctx=Load()))), arg(arg='prefix', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value='')]), body=[Expr(value=Constant(value='Returns an iterator over all modules in the network, yielding\\n        both the name of the module as well as the module itself.\\n\\n        See Also:\\n            :any:`torch.nn.Module.named_modules`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='named_modules', ctx=Load()), args=[], keywords=[keyword(arg='memo', value=Name(id='memo', ctx=Load())), keyword(arg='prefix', value=Name(id='prefix', ctx=Load()))]))], decorator_list=[], returns=Subscript(value=Name(id='Generator', ctx=Load()), slice=Tuple(elts=[Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Attribute(value=Name(id='nn', ctx=Load()), attr='Module', ctx=Load())], ctx=Load()), ctx=Load()), Constant(value=None), Constant(value=None)], ctx=Load()), ctx=Load())), FunctionDef(name='apply', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='fn', annotation=Subscript(value=Name(id='Callable', ctx=Load()), slice=Tuple(elts=[List(elts=[Constant(value='nn.Module')], ctx=Load()), Constant(value=None)], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Expr(value=Constant(value='Applies ``fn`` recursively to every submodule (as returned by ``.children()``)\\n        as well as self. Typical use includes initializing the parameters of a model\\n\\n        See Also:\\n            :any:`torch.nn.Module.apply`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='apply', ctx=Load()), args=[Name(id='fn', ctx=Load())], keywords=[]))], decorator_list=[]), FunctionDef(name='requires_grad_', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='requires_grad', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=True)]), body=[Expr(value=Constant(value='Change if autograd should record operations on parameters in this\\n        module.\\n\\n        See Also:\\n            :any:`torch.nn.Module.requires_grad_`.\\n        ')), Return(value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='requires_grad_', ctx=Load()), args=[], keywords=[keyword(arg='requires_grad', value=Name(id='requires_grad', ctx=Load()))]))], decorator_list=[]), FunctionDef(name='remove_misclassify', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='data', annotation=Subscript(value=Name(id='tuple', ctx=Load()), slice=Tuple(elts=[Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()), Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[]), body=[Expr(value=Constant(value='Remove misclassified samples in a data batch.\\n\\n        Args:\\n            data (tuple[torch.Tensor, torch.Tensor]):\\n                The input and label to process with shape ``(N, *)`` and ``(N)``.\\n            **kwargs: Keyword arguments passed to :meth:`get_data`.\\n\\n        Returns:\\n            (torch.Tensor, torch.Tensor):\\n                The processed input and label with shape ``(N - k, *)`` and ``(N - k)``.\\n        ')), Assign(targets=[Tuple(elts=[Name(id='_input', ctx=Store()), Name(id='_label', ctx=Store())], ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_data', ctx=Load()), args=[Name(id='data', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))])), Assign(targets=[Name(id='_classification', ctx=Store())], value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_class', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[])), Assign(targets=[Name(id='repeat_idx', ctx=Store())], value=Call(func=Attribute(value=Name(id='_classification', ctx=Load()), attr='eq', ctx=Load()), args=[Name(id='_label', ctx=Load())], keywords=[])), Return(value=Tuple(elts=[Subscript(value=Name(id='_input', ctx=Load()), slice=Name(id='repeat_idx', ctx=Load()), ctx=Load()), Subscript(value=Name(id='_label', ctx=Load()), slice=Name(id='repeat_idx', ctx=Load()), ctx=Load())], ctx=Load()))], decorator_list=[Call(func=Attribute(value=Name(id='torch', ctx=Load()), attr='no_grad', ctx=Load()), args=[], keywords=[])]), FunctionDef(name='generate_target', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='idx', annotation=Name(id='int', ctx=Load())), arg(arg='same', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=1), Constant(value=False)]), body=[Expr(value=Constant(value='Generate target labels of a batched input based on\\n            the classification confidence ranking index.\\n\\n        Args:\\n            _input (torch.Tensor): The input tensor.\\n            idx (int): The classification confidence\\n                rank of target class.\\n                Defaults to ``1``.\\n            same (bool): Generate the same label\\n                for all samples using mod.\\n                Defaults to ``False``.\\n\\n        Returns:\\n            torch.Tensor:\\n                The generated target label with shape ``(N)``.\\n\\n        See Also:\\n            The implementation is in\\n            :func:`trojanzoo.utils.model.generate_target()`.\\n        ')), Return(value=Call(func=Name(id='generate_target', ctx=Load()), args=[Name(id='self', ctx=Load()), Name(id='_input', ctx=Load()), Name(id='idx', ctx=Load()), Name(id='same', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), FunctionDef(name='get_parameter_from_name', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='name', annotation=Name(id='str', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value='full')]), body=[Match(subject=Name(id='name', ctx=Load()), cases=[match_case(pattern=MatchValue(value=Constant(value='features')), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='features', ctx=Load()), attr='parameters', ctx=Load()), args=[], keywords=[]))]), match_case(pattern=MatchOr(patterns=[MatchValue(value=Constant(value='classifier')), MatchValue(value=Constant(value='partial'))]), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='classifier', ctx=Load()), attr='parameters', ctx=Load()), args=[], keywords=[]))]), match_case(pattern=MatchValue(value=Constant(value='full')), body=[Assign(targets=[Name(id='params', ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='self', ctx=Load()), attr='_model', ctx=Load()), attr='parameters', ctx=Load()), args=[], keywords=[]))]), match_case(pattern=MatchAs(), body=[Raise(exc=Call(func=Name(id='NotImplementedError', ctx=Load()), args=[JoinedStr(values=[Constant(value='name='), FormattedValue(value=Name(id='name', ctx=Load()), conversion=114)])], keywords=[]))])]), Return(value=Name(id='params', ctx=Load()))], decorator_list=[], returns=Subscript(value=Name(id='Iterator', ctx=Load()), slice=Attribute(value=Name(id='nn', ctx=Load()), attr='Parameter', ctx=Load()), ctx=Load())), FunctionDef(name='__call__', args=arguments(posonlyargs=[], args=[arg(arg='self'), arg(arg='_input', annotation=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load())), arg(arg='amp', annotation=Name(id='bool', ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=False)]), body=[If(test=Name(id='amp', ctx=Load()), body=[With(items=[withitem(context_expr=Call(func=Attribute(value=Attribute(value=Attribute(value=Name(id='torch', ctx=Load()), attr='cuda', ctx=Load()), attr='amp', ctx=Load()), attr='autocast', ctx=Load()), args=[], keywords=[]))], body=[Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_logits', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))])], orelse=[]), Return(value=Call(func=Attribute(value=Name(id='self', ctx=Load()), attr='get_logits', ctx=Load()), args=[Name(id='_input', ctx=Load())], keywords=[keyword(value=Name(id='kwargs', ctx=Load()))]))], decorator_list=[], returns=Attribute(value=Name(id='torch', ctx=Load()), attr='Tensor', ctx=Load()))], decorator_list=[]), FunctionDef(name='add_argument', args=arguments(posonlyargs=[], args=[arg(arg='parser', annotation=Attribute(value=Name(id='argparse', ctx=Load()), attr='ArgumentParser', ctx=Load())), arg(arg='model_name', annotation=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load()))), arg(arg='model', annotation=BinOp(left=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load())), op=BitOr(), right=Name(id='Model', ctx=Load()))), arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='class_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Constant(value=None), Constant(value=None), Name(id='config', ctx=Load()), Dict(keys=[], values=[])]), body=[Expr(value=Constant(value='\\n    | Add model arguments to argument parser.\\n    | For specific arguments implementation, see :meth:`Model.add_argument()`.\\n\\n    Args:\\n        parser (argparse.ArgumentParser): The parser to add arguments.\\n        model_name (str): The model name.\\n        model (str | Model): The model instance or model name\\n            (as the alias of `model_name`).\\n        config (Config): The default parameter config,\\n            which contains the default dataset and model name if not provided.\\n        class_dict (dict[str, type[Model]]):\\n            Map from model name to model class.\\n            Defaults to ``{}``.\\n\\n    Returns:\\n        argparse._ArgumentGroup: The argument group.\\n    ')), Assign(targets=[Name(id='dataset_name', ctx=Store())], value=Call(func=Name(id='get_name', ctx=Load()), args=[], keywords=[keyword(arg='arg_list', value=List(elts=[Constant(value='-d'), Constant(value='--dataset')], ctx=Load()))])), If(test=Compare(left=Name(id='dataset_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dataset_name', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Name(id='config', ctx=Load()), attr='full_config', ctx=Load()), slice=Constant(value='dataset'), ctx=Load()), slice=Constant(value='default_dataset'), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='model_name', ctx=Store())], value=Call(func=Name(id='get_name', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='model_name', ctx=Load())), keyword(arg='module', value=Name(id='model', ctx=Load())), keyword(arg='arg_list', value=List(elts=[Constant(value='-m'), Constant(value='--model')], ctx=Load()))])), If(test=Compare(left=Name(id='model_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='model_name', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='get_config', ctx=Load()), args=[], keywords=[keyword(arg='dataset_name', value=Name(id='dataset_name', ctx=Load()))]), slice=Constant(value='model'), ctx=Load()), slice=Constant(value='default_model'), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='model_name', ctx=Store())], value=Call(func=Name(id='get_model_class', ctx=Load()), args=[Name(id='model_name', ctx=Load())], keywords=[keyword(arg='class_dict', value=Name(id='class_dict', ctx=Load()))])), Assign(targets=[Name(id='group', ctx=Store())], value=Call(func=Attribute(value=Name(id='parser', ctx=Load()), attr='add_argument_group', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{yellow}model{reset}'), attr='format', ctx=Load()), args=[], keywords=[keyword(value=Name(id='ansi', ctx=Load()))])], keywords=[keyword(arg='description', value=Name(id='model_name', ctx=Load()))])), Assign(targets=[Name(id='model_class_name', ctx=Store())], value=Call(func=Name(id='get_model_class', ctx=Load()), args=[Name(id='model_name', ctx=Load())], keywords=[keyword(arg='class_dict', value=Name(id='class_dict', ctx=Load()))])), Try(body=[Assign(targets=[Name(id='ModelType', ctx=Store())], value=Subscript(value=Name(id='class_dict', ctx=Load()), slice=Name(id='model_class_name', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='model_class_name', ctx=Load()), conversion=-1), Constant(value=' not in \\n'), FormattedValue(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='class_dict', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), conversion=-1)])], keywords=[])), Raise()])], orelse=[], finalbody=[]), Return(value=Call(func=Attribute(value=Name(id='ModelType', ctx=Load()), attr='add_argument', ctx=Load()), args=[Name(id='group', ctx=Load())], keywords=[]))], decorator_list=[], returns=Attribute(value=Name(id='argparse', ctx=Load()), attr='_ArgumentGroup', ctx=Load())), FunctionDef(name='create', args=arguments(posonlyargs=[], args=[arg(arg='model_name', annotation=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load()))), arg(arg='model', annotation=BinOp(left=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load())), op=BitOr(), right=Name(id='Model', ctx=Load()))), arg(arg='dataset_name', annotation=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load()))), arg(arg='dataset', annotation=BinOp(left=BinOp(left=Constant(value=None), op=BitOr(), right=Name(id='str', ctx=Load())), op=BitOr(), right=Name(id='Dataset', ctx=Load()))), arg(arg='config', annotation=Name(id='Config', ctx=Load())), arg(arg='class_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='kwargs'), defaults=[Constant(value=None), Constant(value=None), Constant(value=None), Constant(value=None), Name(id='config', ctx=Load()), Dict(keys=[], values=[])]), body=[Expr(value=Constant(value=\"\\n    | Create a model instance.\\n    | For arguments not included in :attr:`kwargs`,\\n      use the default values in :attr:`config`.\\n    | The default value of :attr:`folder_path` is\\n      ``'{model_dir}/{dataset.data_type}/{dataset.name}'``.\\n    | For model implementation, see :class:`Model`.\\n\\n    Args:\\n        model_name (str): The model name.\\n        model (str | Model): The model instance or model name\\n            (as the alias of `model_name`).\\n        dataset_name (str): The dataset name.\\n        dataset (str | trojanzoo.datasets.Dataset):\\n            Dataset instance or dataset name\\n            (as the alias of `dataset_name`).\\n        config (Config): The default parameter config.\\n        class_dict (dict[str, type[Model]]):\\n            Map from model name to model class.\\n            Defaults to ``{}``.\\n        **kwargs: The keyword arguments\\n            passed to model init method.\\n\\n    Returns:\\n        Model: The model instance.\\n    \")), Assign(targets=[Name(id='dataset_name', ctx=Store())], value=Call(func=Name(id='get_name', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='dataset_name', ctx=Load())), keyword(arg='module', value=Name(id='dataset', ctx=Load())), keyword(arg='arg_list', value=List(elts=[Constant(value='-d'), Constant(value='--dataset')], ctx=Load()))])), Assign(targets=[Name(id='model_name', ctx=Store())], value=Call(func=Name(id='get_name', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='model_name', ctx=Load())), keyword(arg='module', value=Name(id='model', ctx=Load())), keyword(arg='arg_list', value=List(elts=[Constant(value='-m'), Constant(value='--model')], ctx=Load()))])), If(test=Compare(left=Name(id='dataset_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='dataset_name', ctx=Store())], value=Subscript(value=Subscript(value=Attribute(value=Name(id='config', ctx=Load()), attr='full_config', ctx=Load()), slice=Constant(value='dataset'), ctx=Load()), slice=Constant(value='default_dataset'), ctx=Load()))], orelse=[]), If(test=Compare(left=Name(id='model_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), body=[Assign(targets=[Name(id='model_name', ctx=Store())], value=Subscript(value=Subscript(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='get_config', ctx=Load()), args=[], keywords=[keyword(arg='dataset_name', value=Name(id='dataset_name', ctx=Load()))]), slice=Constant(value='model'), ctx=Load()), slice=Constant(value='default_model'), ctx=Load()))], orelse=[]), Assign(targets=[Name(id='result', ctx=Store())], value=Call(func=Attribute(value=Subscript(value=Call(func=Attribute(value=Name(id='config', ctx=Load()), attr='get_config', ctx=Load()), args=[], keywords=[keyword(arg='dataset_name', value=Name(id='dataset_name', ctx=Load()))]), slice=Constant(value='model'), ctx=Load()), attr='update', ctx=Load()), args=[Name(id='kwargs', ctx=Load())], keywords=[])), Assign(targets=[Name(id='model_name', ctx=Store())], value=IfExp(test=Compare(left=Name(id='model_name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=Name(id='model_name', ctx=Load()), orelse=Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='default_model'), ctx=Load()))), Assign(targets=[Name(id='name_list', ctx=Store())], value=ListComp(elt=Name(id='name', ctx=Load()), generators=[comprehension(target=Name(id='sub_list', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id='get_available_models', ctx=Load()), args=[], keywords=[keyword(arg='class_dict', value=Name(id='class_dict', ctx=Load()))]), attr='values', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0), comprehension(target=Name(id='name', ctx=Store()), iter=Name(id='sub_list', ctx=Load()), ifs=[], is_async=0)])), Assign(targets=[Name(id='name_list', ctx=Store())], value=Call(func=Name(id='sorted', ctx=Load()), args=[Name(id='name_list', ctx=Load())], keywords=[])), Assert(test=Compare(left=Name(id='model_name', ctx=Load()), ops=[In()], comparators=[Name(id='name_list', ctx=Load())]), msg=JoinedStr(values=[FormattedValue(value=Name(id='model_name', ctx=Load()), conversion=-1), Constant(value=' not in \\n'), FormattedValue(value=Name(id='name_list', ctx=Load()), conversion=-1)])), Assign(targets=[Name(id='model_class_name', ctx=Store())], value=Call(func=Name(id='get_model_class', ctx=Load()), args=[Name(id='model_name', ctx=Load())], keywords=[keyword(arg='class_dict', value=Name(id='class_dict', ctx=Load()))])), Try(body=[Assign(targets=[Name(id='ModelType', ctx=Store())], value=Subscript(value=Name(id='class_dict', ctx=Load()), slice=Name(id='model_class_name', ctx=Load()), ctx=Load()))], handlers=[ExceptHandler(type=Name(id='KeyError', ctx=Load()), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='model_class_name', ctx=Load()), conversion=-1), Constant(value=' not in \\n'), FormattedValue(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='class_dict', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), conversion=-1)])], keywords=[])), Raise()])], orelse=[], finalbody=[]), If(test=BoolOp(op=And(), values=[Compare(left=Constant(value='folder_path'), ops=[NotIn()], comparators=[Call(func=Attribute(value=Name(id='result', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])]), Call(func=Name(id='isinstance', ctx=Load()), args=[Name(id='dataset', ctx=Load()), Name(id='Dataset', ctx=Load())], keywords=[])]), body=[Assign(targets=[Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='folder_path'), ctx=Store())], value=Call(func=Attribute(value=Attribute(value=Name(id='os', ctx=Load()), attr='path', ctx=Load()), attr='join', ctx=Load()), args=[Subscript(value=Name(id='result', ctx=Load()), slice=Constant(value='model_dir'), ctx=Load()), Attribute(value=Name(id='dataset', ctx=Load()), attr='data_type', ctx=Load()), Attribute(value=Name(id='dataset', ctx=Load()), attr='name', ctx=Load())], keywords=[]))], orelse=[]), Return(value=Call(func=Name(id='ModelType', ctx=Load()), args=[], keywords=[keyword(arg='name', value=Name(id='model_name', ctx=Load())), keyword(arg='dataset', value=Name(id='dataset', ctx=Load())), keyword(arg='dataset_name', value=Name(id='dataset_name', ctx=Load())), keyword(value=Name(id='result', ctx=Load()))]))], decorator_list=[], returns=Name(id='Model', ctx=Load())), FunctionDef(name='output_available_models', args=arguments(posonlyargs=[], args=[arg(arg='class_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), arg(arg='indent', annotation=Name(id='int', ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[]), Constant(value=0)]), body=[Expr(value=Constant(value='Output all available model names.\\n\\n    Args:\\n        class_dict (dict[str, type[Model]]): Map from model name to model class.\\n            Defaults to ``{}``.\\n        indent (int): The space indent for the entire string.\\n            Defaults to ``0``.\\n    ')), Assign(targets=[Name(id='names_dict', ctx=Store())], value=Call(func=Name(id='get_available_models', ctx=Load()), args=[Name(id='class_dict', ctx=Load())], keywords=[])), For(target=Name(id='k', ctx=Store()), iter=Call(func=Name(id='sorted', ctx=Load()), args=[Call(func=Attribute(value=Name(id='names_dict', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), body=[Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[Call(func=Attribute(value=Constant(value='{yellow}{k}{reset}'), attr='format', ctx=Load()), args=[], keywords=[keyword(arg='k', value=Name(id='k', ctx=Load())), keyword(value=Name(id='ansi', ctx=Load()))])], keywords=[keyword(arg='indent', value=Name(id='indent', ctx=Load()))])), Expr(value=Call(func=Name(id='prints', ctx=Load()), args=[Subscript(value=Name(id='names_dict', ctx=Load()), slice=Name(id='k', ctx=Load()), ctx=Load())], keywords=[keyword(arg='indent', value=BinOp(left=Name(id='indent', ctx=Load()), op=Add(), right=Constant(value=10)))])), Expr(value=Call(func=Name(id='print', ctx=Load()), args=[], keywords=[]))], orelse=[])], decorator_list=[], returns=Constant(value=None)), FunctionDef(name='get_available_models', args=arguments(posonlyargs=[], args=[arg(arg='class_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[])]), body=[Return(value=DictComp(key=Name(id='k', ctx=Load()), value=Attribute(value=Name(id='v', ctx=Load()), attr='available_models', ctx=Load()), generators=[comprehension(target=Tuple(elts=[Name(id='k', ctx=Store()), Name(id='v', ctx=Store())], ctx=Store()), iter=Call(func=Attribute(value=Name(id='class_dict', ctx=Load()), attr='items', ctx=Load()), args=[], keywords=[]), ifs=[], is_async=0)]))], decorator_list=[], returns=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='set', ctx=Load()), slice=Name(id='str', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load())), FunctionDef(name='get_model_class', args=arguments(posonlyargs=[], args=[arg(arg='name', annotation=Name(id='str', ctx=Load())), arg(arg='class_dict', annotation=Subscript(value=Name(id='dict', ctx=Load()), slice=Tuple(elts=[Name(id='str', ctx=Load()), Subscript(value=Name(id='type', ctx=Load()), slice=Name(id='Model', ctx=Load()), ctx=Load())], ctx=Load()), ctx=Load()))], kwonlyargs=[], kw_defaults=[], defaults=[Dict(keys=[], values=[])]), body=[AnnAssign(target=Name(id='correct_name', ctx=Store()), annotation=Name(id='str', ctx=Load()), value=Constant(value=None), simple=1), For(target=Name(id='class_name', ctx=Store()), iter=Call(func=Attribute(value=Name(id='class_dict', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[]), body=[If(test=BoolOp(op=And(), values=[Compare(left=Name(id='class_name', ctx=Load()), ops=[In()], comparators=[Call(func=Attribute(value=Name(id='name', ctx=Load()), attr='lower', ctx=Load()), args=[], keywords=[])]), BoolOp(op=Or(), values=[Compare(left=Name(id='correct_name', ctx=Load()), ops=[Is()], comparators=[Constant(value=None)]), Compare(left=Call(func=Name(id='len', ctx=Load()), args=[Name(id='class_name', ctx=Load())], keywords=[]), ops=[Gt()], comparators=[Call(func=Name(id='len', ctx=Load()), args=[Name(id='correct_name', ctx=Load())], keywords=[])])])]), body=[Assign(targets=[Name(id='correct_name', ctx=Store())], value=Name(id='class_name', ctx=Load()))], orelse=[])], orelse=[]), If(test=Compare(left=Name(id='correct_name', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Return(value=Name(id='correct_name', ctx=Load()))], orelse=[]), Raise(exc=Call(func=Name(id='KeyError', ctx=Load()), args=[JoinedStr(values=[FormattedValue(value=Name(id='name', ctx=Load()), conversion=-1), Constant(value=' not in '), FormattedValue(value=Call(func=Name(id='list', ctx=Load()), args=[Call(func=Attribute(value=Name(id='class_dict', ctx=Load()), attr='keys', ctx=Load()), args=[], keywords=[])], keywords=[]), conversion=-1)])], keywords=[]))], decorator_list=[], returns=Name(id='str', ctx=Load()))], type_ignores=[])"